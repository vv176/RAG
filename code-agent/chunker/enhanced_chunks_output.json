{
  "chunks": [
    {
      "type": "imports",
      "name": "module_imports",
      "content": "Module Dependencies:\n\nThird Party: fastapi\n  - FastAPI\n\nThird Party: fastapi.middleware.cors\n  - CORSMiddleware\n\nThird Party: contextlib\n  - asynccontextmanager\n\nLocal: app.core.config\n  - settings\n\nLocal: app.core.database\n  - init_db\n\nLocal: app.api.v1.router\n  - api_router\n\nThird Party: uvicorn\n  - uvicorn",
      "metadata": {
        "file_path": "main.py",
        "chunk_type": "imports",
        "name": "module_imports",
        "purpose": "Module dependencies and imports",
        "dependencies": [],
        "access_level": "public",
        "imports": [
          {
            "module": "fastapi",
            "type": "third_party",
            "items": [
              "FastAPI"
            ]
          },
          {
            "module": "fastapi.middleware.cors",
            "type": "third_party",
            "items": [
              "CORSMiddleware"
            ]
          },
          {
            "module": "contextlib",
            "type": "third_party",
            "items": [
              "asynccontextmanager"
            ]
          },
          {
            "module": "app.core.config",
            "type": "local",
            "items": [
              "settings"
            ]
          },
          {
            "module": "app.core.database",
            "type": "local",
            "items": [
              "init_db"
            ]
          },
          {
            "module": "app.api.v1.router",
            "type": "local",
            "items": [
              "api_router"
            ]
          },
          {
            "module": "uvicorn",
            "type": "third_party",
            "items": [
              "uvicorn"
            ]
          }
        ]
      },
      "description": "The `module_imports` Python module manages dependencies essential for the application's functionality. It incorporates several third-party libraries, including **FastAPI** for building web applications and **Uvicorn** as an ASGI server for running the application. Additionally, it utilizes **CORSMiddleware** from FastAPI to handle Cross-Origin Resource Sharing (CORS) requests, ensuring secure interactions between different origins.\n\nThe module also leverages **asynccontextmanager** from the **contextlib** library to facilitate asynchronous resource management. On the local level, it imports configuration settings from `app.core.config`, initializes the database with `init_db` from `app.core.database`, and sets up routing for the API through `api_router` from `app.api.v1.router`.\n\nOverall, this module serves as a foundational component that integrates essential configurations, database initialization, and API routing while relying on robust external libraries to enhance web application capabilities."
    },
    {
      "type": "function",
      "name": "create_app",
      "content": "def create_app() -> FastAPI:\n    \"\"\"Create and configure FastAPI application\"\"\"\n    app = FastAPI(\n        title=\"E-commerce API\",\n        description=\"A modern e-commerce platform built with FastAPI\",\n        version=\"1.0.0\",\n        lifespan=lifespan\n    )\n    \n    # CORS middleware\n    app.add_middleware(\n        CORSMiddleware,\n        allow_origins=settings.ALLOWED_HOSTS,\n        allow_credentials=True,\n        allow_methods=[\"*\"],\n        allow_headers=[\"*\"],\n    )\n    \n    # Include API router\n    app.include_router(api_router, prefix=\"/api/v1\")\n    \n    return app",
      "metadata": {
        "file_path": "main.py",
        "chunk_type": "function",
        "name": "create_app",
        "purpose": "Create and configure FastAPI application",
        "dependencies": [],
        "access_level": "public",
        "function_name": "create_app",
        "parameters": [],
        "return_type": "FastAPI",
        "decorators": [],
        "is_async": false
      },
      "description": "**Description of `create_app` Function:**\n\nThe `create_app` function is designed to instantiate and configure a FastAPI application tailored for an e-commerce platform. It does not accept any parameters. Upon execution, it returns a fully configured FastAPI instance. \n\nKey features include:\n- Setting application metadata such as title, description, and version.\n- Implementing Cross-Origin Resource Sharing (CORS) middleware to manage allowed origins, credentials, methods, and headers, enhancing security and flexibility for API interactions.\n- Integrating an API router with a specified prefix (`/api/v1`) to organize endpoints effectively.\n\nDevelopers would use this function when initializing a new FastAPI application, particularly for e-commerce projects, to streamline setup and ensure consistent configurations. It addresses common challenges such as CORS management and modular API routing, facilitating a robust foundation for building scalable web applications."
    },
    {
      "type": "main_block",
      "name": "__main__",
      "content": "if __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(\n        \"main:app\",\n        host=\"0.0.0.0\",\n        port=8000,\n        reload=True\n    )",
      "metadata": {
        "file_path": "main.py",
        "chunk_type": "main_block",
        "name": "__main__",
        "purpose": "Entry point when run as script",
        "dependencies": [],
        "access_level": "public",
        "calls": [
          "run"
        ]
      },
      "description": "This code snippet serves as the entry point for a Python script when executed directly. It checks if the script is being run as the main module using the conditional `if __name__ == \"__main__\":`. If true, it imports the `uvicorn` server and starts it to run a FastAPI application defined in the `main` module, specifically the `app` instance. The server listens on all available IP addresses (`0.0.0.0`) at port `8000`, with the `reload` option enabled for automatic code reloading during development. This setup is commonly used for running web applications built with FastAPI in a local development environment."
    },
    {
      "type": "imports",
      "name": "module_imports",
      "content": "Module Dependencies:\n\nThird Party: pytest\n  - pytest\n\nThird Party: fastapi.testclient\n  - TestClient\n\nThird Party: sqlalchemy.orm\n  - Session\n\nThird Party: decimal\n  - Decimal\n\nThird Party: main\n  - app\n\nLocal: app.core.database\n  - get_db\n\nLocal: app.models.user\n  - User\n\nLocal: app.models.product\n  - Product\n\nLocal: app.models.category\n  - Category\n\nLocal: app.core.security\n  - get_password_hash, create_access_token",
      "metadata": {
        "file_path": "tests/test_products.py",
        "chunk_type": "imports",
        "name": "module_imports",
        "purpose": "Module dependencies and imports",
        "dependencies": [],
        "access_level": "public",
        "imports": [
          {
            "module": "pytest",
            "type": "third_party",
            "items": [
              "pytest"
            ]
          },
          {
            "module": "fastapi.testclient",
            "type": "third_party",
            "items": [
              "TestClient"
            ]
          },
          {
            "module": "sqlalchemy.orm",
            "type": "third_party",
            "items": [
              "Session"
            ]
          },
          {
            "module": "decimal",
            "type": "third_party",
            "items": [
              "Decimal"
            ]
          },
          {
            "module": "main",
            "type": "third_party",
            "items": [
              "app"
            ]
          },
          {
            "module": "app.core.database",
            "type": "local",
            "items": [
              "get_db"
            ]
          },
          {
            "module": "app.models.user",
            "type": "local",
            "items": [
              "User"
            ]
          },
          {
            "module": "app.models.product",
            "type": "local",
            "items": [
              "Product"
            ]
          },
          {
            "module": "app.models.category",
            "type": "local",
            "items": [
              "Category"
            ]
          },
          {
            "module": "app.core.security",
            "type": "local",
            "items": [
              "get_password_hash",
              "create_access_token"
            ]
          }
        ]
      },
      "description": "The `module_imports` Python module outlines essential dependencies and imports required for its functionality. It relies on several third-party libraries, including `pytest` for testing, `fastapi.testclient` for HTTP client functionality in FastAPI applications, `sqlalchemy.orm` for ORM capabilities with the `Session` class, and `decimal` for precise decimal arithmetic. \n\nAdditionally, it imports local modules such as `app.core.database` for database connection management via `get_db`, `app.models.user`, `app.models.product`, and `app.models.category` for user, product, and category data models, respectively. It also includes security functions from `app.core.security`, specifically `get_password_hash` for password hashing and `create_access_token` for generating access tokens.\n\nThis module is integral to the system as it facilitates database interactions, user authentication, and testing, ensuring a robust and secure FastAPI application. The combination of local and third-party dependencies enhances its functionality and integration within the overall architecture."
    },
    {
      "type": "function",
      "name": "admin_user",
      "content": "def admin_user(db: Session):\n    \"\"\"Create admin user\"\"\"\n    user = User(\n        email=\"admin@example.com\",\n        username=\"admin\",\n        hashed_password=get_password_hash(\"adminpassword\"),\n        first_name=\"Admin\",\n        last_name=\"User\",\n        is_admin=True\n    )\n    db.add(user)\n    db.commit()\n    db.refresh(user)\n    return user",
      "metadata": {
        "file_path": "tests/test_products.py",
        "chunk_type": "function",
        "name": "admin_user",
        "purpose": "Create admin user",
        "dependencies": [],
        "access_level": "public",
        "function_name": "admin_user",
        "parameters": [
          "db: Session"
        ],
        "return_type": "",
        "decorators": [
          "pytest.fixture"
        ],
        "is_async": false
      },
      "description": "**Function Description: `admin_user`**\n\nThe `admin_user` function is designed to create a new admin user in a database. It takes a single parameter, `db`, which is an instance of `Session` from SQLAlchemy, representing the database session for executing operations. \n\nUpon execution, the function initializes a `User` object with predefined attributes, including a hardcoded email, username, hashed password, first name, last name, and an admin flag set to `True`. It then adds this user to the database, commits the transaction, and refreshes the user object to ensure it reflects the latest state from the database. Finally, the function returns the newly created user object.\n\nDevelopers would use this function when setting up an application that requires an initial admin user, particularly during the deployment or setup phase. It addresses the need for a secure and easily identifiable admin account, facilitating administrative access to the application from the outset."
    },
    {
      "type": "function",
      "name": "regular_user",
      "content": "def regular_user(db: Session):\n    \"\"\"Create regular user\"\"\"\n    user = User(\n        email=\"user@example.com\",\n        username=\"user\",\n        hashed_password=get_password_hash(\"userpassword\"),\n        first_name=\"Regular\",\n        last_name=\"User\"\n    )\n    db.add(user)\n    db.commit()\n    db.refresh(user)\n    return user",
      "metadata": {
        "file_path": "tests/test_products.py",
        "chunk_type": "function",
        "name": "regular_user",
        "purpose": "Create regular user",
        "dependencies": [],
        "access_level": "public",
        "function_name": "regular_user",
        "parameters": [
          "db: Session"
        ],
        "return_type": "",
        "decorators": [
          "pytest.fixture"
        ],
        "is_async": false
      },
      "description": "The `regular_user` function in Python is designed to create and store a new regular user in a database. It takes a single parameter, `db`, which is a database session of type `Session`. The function initializes a `User` object with predefined attributes such as email, username, hashed password, first name, and last name. After creating the user object, it adds it to the database session, commits the transaction to save the user, and refreshes the user object to reflect the latest data from the database. The function ultimately returns the newly created user object.\n\nDevelopers would use this function when they need to programmatically create a standard user account in an application, particularly in scenarios involving user registration or account setup. It addresses the problem of user creation by encapsulating the logic for initializing user attributes, handling database interactions, and ensuring that the user data is securely hashed before storage."
    },
    {
      "type": "function",
      "name": "test_category",
      "content": "def test_category(db: Session):\n    \"\"\"Create test category\"\"\"\n    category = Category(\n        name=\"Electronics\",\n        slug=\"electronics\",\n        description=\"Electronic devices and accessories\"\n    )\n    db.add(category)\n    db.commit()\n    db.refresh(category)\n    return category",
      "metadata": {
        "file_path": "tests/test_products.py",
        "chunk_type": "function",
        "name": "test_category",
        "purpose": "Create test category",
        "dependencies": [],
        "access_level": "public",
        "function_name": "test_category",
        "parameters": [
          "db: Session"
        ],
        "return_type": "",
        "decorators": [
          "pytest.fixture"
        ],
        "is_async": false
      },
      "description": "The `test_category` function in Python is designed to create and store a new category in a database. It takes a single parameter, `db`, which is an instance of `Session` from SQLAlchemy, representing the database session for executing operations. The function constructs a `Category` object with predefined attributes: a name (\"Electronics\"), a slug (\"electronics\"), and a description (\"Electronic devices and accessories\"). After adding the category to the database, it commits the transaction and refreshes the category object to reflect the latest state from the database. The function returns the created `Category` object.\n\nDevelopers would use this function in scenarios where they need to set up a test environment with predefined categories, particularly for applications involving e-commerce or inventory management. It solves the problem of manually creating and managing test data, streamlining the process of populating the database with necessary entities for testing purposes."
    },
    {
      "type": "function",
      "name": "test_product",
      "content": "def test_product(db: Session, test_category):\n    \"\"\"Create test product\"\"\"\n    product = Product(\n        name=\"Test Product\",\n        description=\"A test product\",\n        price=Decimal(\"99.99\"),\n        sku=\"TEST-001\",\n        stock_quantity=10,\n        category_id=test_category.id\n    )\n    db.add(product)\n    db.commit()\n    db.refresh(product)\n    return product",
      "metadata": {
        "file_path": "tests/test_products.py",
        "chunk_type": "function",
        "name": "test_product",
        "purpose": "Create test product",
        "dependencies": [],
        "access_level": "public",
        "function_name": "test_product",
        "parameters": [
          "db: Session",
          "test_category"
        ],
        "return_type": "",
        "decorators": [
          "pytest.fixture"
        ],
        "is_async": false
      },
      "description": "The `test_product` function is a Python utility designed to create and persist a test product in a database. It takes two parameters: `db`, which is a SQLAlchemy `Session` object for database operations, and `test_category`, which is an object representing the category to which the product belongs. The function constructs a `Product` instance with predefined attributes such as name, description, price, SKU, stock quantity, and associates it with the provided category ID. After adding the product to the database, it commits the transaction and refreshes the product object to reflect the latest state from the database. The function returns the created `Product` object.\n\nDevelopers would use this function primarily in testing scenarios where a mock product is needed to validate application behavior or functionality without affecting real data. It addresses the need for quick and reliable test data generation, facilitating unit tests and integration tests in e-commerce applications."
    },
    {
      "type": "function",
      "name": "get_auth_headers",
      "content": "def get_auth_headers(user: User):\n    \"\"\"Get authorization headers for user\"\"\"\n    token = create_access_token(data={\"sub\": str(user.id)})\n    return {\"Authorization\": f\"Bearer {token}\"}",
      "metadata": {
        "file_path": "tests/test_products.py",
        "chunk_type": "function",
        "name": "get_auth_headers",
        "purpose": "Get authorization headers for user",
        "dependencies": [],
        "access_level": "public",
        "function_name": "get_auth_headers",
        "parameters": [
          "user: User"
        ],
        "return_type": "",
        "decorators": [],
        "is_async": false
      },
      "description": "The `get_auth_headers` function generates authorization headers for a specified user in a Python application. It accepts a single parameter, `user`, which is an instance of the `User` class. The function creates a JSON Web Token (JWT) using the user's ID as the subject, leveraging the `create_access_token` utility. It returns a dictionary containing the authorization header formatted as a Bearer token. \n\nDevelopers would use this function when implementing authentication mechanisms in web applications, particularly when securing API endpoints. It solves the problem of generating valid authorization tokens that can be used to authenticate user requests, ensuring secure access to resources."
    },
    {
      "type": "function",
      "name": "test_get_products",
      "content": "def test_get_products():\n    \"\"\"Test getting products list\"\"\"\n    response = client.get(\"/api/v1/products/\")\n    assert response.status_code == 200\n    data = response.json()\n    assert \"products\" in data\n    assert \"total\" in data",
      "metadata": {
        "file_path": "tests/test_products.py",
        "chunk_type": "function",
        "name": "test_get_products",
        "purpose": "Test getting products list",
        "dependencies": [],
        "access_level": "public",
        "function_name": "test_get_products",
        "parameters": [],
        "return_type": "",
        "decorators": [],
        "is_async": false
      },
      "description": "**Description of `test_get_products` Function:**\n\nThe `test_get_products` function is a unit test designed to verify the functionality of the API endpoint that retrieves a list of products. It does not accept any parameters. The function sends a GET request to the `/api/v1/products/` endpoint and checks if the response status code is 200, indicating a successful request. It then parses the JSON response to ensure that it contains the keys \"products\" and \"total\". \n\nDevelopers would use this function during the testing phase of API development to ensure that the product retrieval feature works as intended. It helps identify issues with the API response structure or status codes, ensuring that the endpoint behaves correctly and returns the expected data format. This function is essential for maintaining the reliability and correctness of the product listing feature in an application."
    },
    {
      "type": "function",
      "name": "test_get_products_with_filters",
      "content": "def test_get_products_with_filters(test_product):\n    \"\"\"Test getting products with filters\"\"\"\n    response = client.get(\"/api/v1/products/?search=Test&in_stock_only=true\")\n    assert response.status_code == 200\n    data = response.json()\n    assert len(data[\"products\"]) >= 1",
      "metadata": {
        "file_path": "tests/test_products.py",
        "chunk_type": "function",
        "name": "test_get_products_with_filters",
        "purpose": "Test getting products with filters",
        "dependencies": [],
        "access_level": "public",
        "function_name": "test_get_products_with_filters",
        "parameters": [
          "test_product"
        ],
        "return_type": "",
        "decorators": [],
        "is_async": false
      },
      "description": "**Description of `test_get_products_with_filters` Function:**\n\nThe `test_get_products_with_filters` function is a unit test designed to verify the functionality of retrieving products from an API with specific filters applied. It expects a single input parameter, `test_product`, which is presumably used for context in the test but is not directly utilized within the function. \n\nWhen executed, the function sends a GET request to the API endpoint `/api/v1/products/` with query parameters to search for products containing \"Test\" and to filter for items that are in stock. The function asserts that the HTTP response status code is 200, indicating a successful request, and checks that the returned JSON data contains at least one product in the \"products\" list.\n\nDevelopers would use this function during the testing phase of API development to ensure that the product retrieval feature works correctly under specified conditions. It helps identify issues related to product filtering and availability, ensuring that the API behaves as expected when queried with filters.\n\nIn"
    },
    {
      "type": "function",
      "name": "test_get_product_by_id",
      "content": "def test_get_product_by_id(test_product):\n    \"\"\"Test getting product by ID\"\"\"\n    response = client.get(f\"/api/v1/products/{test_product.id}\")\n    assert response.status_code == 200\n    data = response.json()\n    assert data[\"name\"] == \"Test Product\"\n    assert data[\"sku\"] == \"TEST-001\"",
      "metadata": {
        "file_path": "tests/test_products.py",
        "chunk_type": "function",
        "name": "test_get_product_by_id",
        "purpose": "Test getting product by ID",
        "dependencies": [],
        "access_level": "public",
        "function_name": "test_get_product_by_id",
        "parameters": [
          "test_product"
        ],
        "return_type": "",
        "decorators": [],
        "is_async": false
      },
      "description": "The `test_get_product_by_id` function is a unit test designed to verify the functionality of retrieving a product by its unique identifier (ID) from an API endpoint. It accepts a single parameter, `test_product`, which is expected to be an object containing the product's attributes, including its ID. \n\nUpon execution, the function sends a GET request to the API endpoint `/api/v1/products/{test_product.id}` and checks that the server responds with a status code of 200, indicating a successful request. It then parses the JSON response to assert that the product's name is \"Test Product\" and its SKU is \"TEST-001\". \n\nDevelopers would use this function during the testing phase of API development to ensure that the product retrieval functionality works as intended. It helps identify issues related to product data retrieval, ensuring that the API correctly returns expected product details based on the provided ID. This function is crucial for maintaining the reliability and accuracy of the product management system in an application."
    },
    {
      "type": "function",
      "name": "test_get_nonexistent_product",
      "content": "def test_get_nonexistent_product():\n    \"\"\"Test getting non-existent product\"\"\"\n    response = client.get(\"/api/v1/products/99999\")\n    assert response.status_code == 404",
      "metadata": {
        "file_path": "tests/test_products.py",
        "chunk_type": "function",
        "name": "test_get_nonexistent_product",
        "purpose": "Test getting non-existent product",
        "dependencies": [],
        "access_level": "public",
        "function_name": "test_get_nonexistent_product",
        "parameters": [],
        "return_type": "",
        "decorators": [],
        "is_async": false
      },
      "description": "**Function Description: `test_get_nonexistent_product`**\n\nThe `test_get_nonexistent_product` function is a unit test designed to verify the behavior of an API endpoint when attempting to retrieve a product that does not exist. This function does not take any parameters and sends a GET request to the endpoint `/api/v1/products/99999`, where `99999` is an arbitrary product ID assumed to be non-existent. \n\nThe function checks if the response status code is `404`, indicating that the product was not found. Developers would use this function during the testing phase to ensure that the API correctly handles requests for non-existent resources, thereby validating error handling and improving user experience. This test helps identify potential issues in the API's routing and response mechanisms, ensuring robustness and reliability in product retrieval functionalities."
    },
    {
      "type": "function",
      "name": "test_create_product_as_admin",
      "content": "def test_create_product_as_admin(db: Session, admin_user, test_category):\n    \"\"\"Test creating product as admin\"\"\"\n    product_data = {\n        \"name\": \"New Product\",\n        \"description\": \"A new product\",\n        \"price\": 149.99,\n        \"sku\": \"NEW-001\",\n        \"stock_quantity\": 5,\n        \"category_id\": test_category.id\n    }\n    \n    response = client.post(\n        \"/api/v1/products/\",\n        json=product_data,\n        headers=get_auth_headers(admin_user)\n    )\n    \n    assert response.status_code == 201\n    data = response.json()\n    assert data[\"name\"] == \"New Product\"\n    assert data[\"sku\"] == \"NEW-001\"",
      "metadata": {
        "file_path": "tests/test_products.py",
        "chunk_type": "function",
        "name": "test_create_product_as_admin",
        "purpose": "Test creating product as admin",
        "dependencies": [],
        "access_level": "public",
        "function_name": "test_create_product_as_admin",
        "parameters": [
          "db: Session",
          "admin_user",
          "test_category"
        ],
        "return_type": "",
        "decorators": [],
        "is_async": false
      },
      "description": "**Function Description: `test_create_product_as_admin`**\n\nThe `test_create_product_as_admin` function is a unit test designed to verify the functionality of creating a new product through an API endpoint, specifically when executed by an admin user. \n\n**Inputs:**\n- `db: Session`: A database session object for interacting with the database.\n- `admin_user`: An object representing the admin user, which is used for authentication.\n- `test_category`: A category object that provides the ID for the product's category.\n\n**Returns:**\n- The function does not return a value but asserts that the API response status code is 201 (indicating successful creation) and checks that the returned product data matches the expected values.\n\n**Usage:**\nDevelopers would use this function during the testing phase of application development to ensure that the product creation feature works correctly for admin users. It helps confirm that the API behaves as expected when valid data is provided.\n\n**Problem Solved:**\nThis function addresses"
    },
    {
      "type": "function",
      "name": "test_create_product_as_regular_user",
      "content": "def test_create_product_as_regular_user(regular_user):\n    \"\"\"Test creating product as regular user (should fail)\"\"\"\n    product_data = {\n        \"name\": \"New Product\",\n        \"description\": \"A new product\",\n        \"price\": 149.99,\n        \"sku\": \"NEW-002\",\n        \"stock_quantity\": 5\n    }\n    \n    response = client.post(\n        \"/api/v1/products/\",\n        json=product_data,\n        headers=get_auth_headers(regular_user)\n    )\n    \n    assert response.status_code == 403",
      "metadata": {
        "file_path": "tests/test_products.py",
        "chunk_type": "function",
        "name": "test_create_product_as_regular_user",
        "purpose": "Test creating product as regular user (should fail)",
        "dependencies": [],
        "access_level": "public",
        "function_name": "test_create_product_as_regular_user",
        "parameters": [
          "regular_user"
        ],
        "return_type": "",
        "decorators": [],
        "is_async": false
      },
      "description": "**Description of `test_create_product_as_regular_user` Function:**\n\nThe `test_create_product_as_regular_user` function is a unit test designed to verify that a regular user cannot create a product in the application, ensuring that proper access controls are enforced. It expects a single input parameter, `regular_user`, which represents the credentials of a non-admin user. \n\nUpon execution, the function attempts to create a product by sending a POST request to the `/api/v1/products/` endpoint with a predefined product data dictionary containing attributes such as name, description, price, SKU, and stock quantity. The test asserts that the response status code is 403, indicating that the action is forbidden for regular users.\n\nDevelopers would use this function during the testing phase of application development to confirm that the system correctly restricts product creation to authorized users only, thereby preventing unauthorized access and potential misuse of the product management functionality. This function helps ensure compliance with security policies and enhances the overall integrity of the application."
    },
    {
      "type": "function",
      "name": "test_create_product_duplicate_sku",
      "content": "def test_create_product_duplicate_sku(db: Session, admin_user, test_product):\n    \"\"\"Test creating product with duplicate SKU\"\"\"\n    product_data = {\n        \"name\": \"Another Product\",\n        \"description\": \"Another product\",\n        \"price\": 199.99,\n        \"sku\": \"TEST-001\",  # Same SKU as test_product\n        \"stock_quantity\": 3\n    }\n    \n    response = client.post(\n        \"/api/v1/products/\",\n        json=product_data,\n        headers=get_auth_headers(admin_user)\n    )\n    \n    assert response.status_code == 400\n    assert \"already exists\" in response.json()[\"detail\"]",
      "metadata": {
        "file_path": "tests/test_products.py",
        "chunk_type": "function",
        "name": "test_create_product_duplicate_sku",
        "purpose": "Test creating product with duplicate SKU",
        "dependencies": [],
        "access_level": "public",
        "function_name": "test_create_product_duplicate_sku",
        "parameters": [
          "db: Session",
          "admin_user",
          "test_product"
        ],
        "return_type": "",
        "decorators": [],
        "is_async": false
      },
      "description": "**Function Description: `test_create_product_duplicate_sku`**\n\nThe `test_create_product_duplicate_sku` function is a unit test designed to validate the behavior of a product creation API endpoint when attempting to create a product with a duplicate SKU. It takes three parameters: a database session (`db: Session`), an admin user object (`admin_user`), and a test product object (`test_product`). \n\nUpon execution, the function constructs a product data dictionary with a name, description, price, stock quantity, and a SKU that matches an existing product's SKU. It then sends a POST request to the `/api/v1/products/` endpoint with this data, authenticated using the admin user's credentials. \n\nThe function asserts that the API response returns a status code of 400, indicating a bad request, and checks that the response message contains \"already exists,\" confirming that the system correctly identifies and rejects the duplicate SKU.\n\nDevelopers would use this function during testing to ensure that the product creation logic"
    },
    {
      "type": "function",
      "name": "test_update_product_as_admin",
      "content": "def test_update_product_as_admin(db: Session, admin_user, test_product):\n    \"\"\"Test updating product as admin\"\"\"\n    update_data = {\n        \"name\": \"Updated Product\",\n        \"price\": 129.99\n    }\n    \n    response = client.put(\n        f\"/api/v1/products/{test_product.id}\",\n        json=update_data,\n        headers=get_auth_headers(admin_user)\n    )\n    \n    assert response.status_code == 200\n    data = response.json()\n    assert data[\"name\"] == \"Updated Product\"\n    assert float(data[\"price\"]) == 129.99",
      "metadata": {
        "file_path": "tests/test_products.py",
        "chunk_type": "function",
        "name": "test_update_product_as_admin",
        "purpose": "Test updating product as admin",
        "dependencies": [],
        "access_level": "public",
        "function_name": "test_update_product_as_admin",
        "parameters": [
          "db: Session",
          "admin_user",
          "test_product"
        ],
        "return_type": "",
        "decorators": [],
        "is_async": false
      },
      "description": "**Function Description: `test_update_product_as_admin`**\n\nThe `test_update_product_as_admin` function is a unit test designed to verify the functionality of updating a product's details through an API endpoint, specifically when performed by an admin user. \n\n**Inputs:**\n- `db: Session`: A database session object for interacting with the database.\n- `admin_user`: An object representing the admin user who has the necessary permissions to update products.\n- `test_product`: An object representing the product to be updated, which includes its unique identifier.\n\n**Returns:**\nThe function does not return a value; instead, it asserts that the HTTP response status code is 200 (indicating success) and checks that the product's name and price have been updated correctly in the response data.\n\n**Usage Context:**\nDevelopers would use this function during the testing phase of API development to ensure that the product update functionality works as intended for admin users. It helps confirm that the API correctly processes update requests"
    },
    {
      "type": "function",
      "name": "test_delete_product_as_admin",
      "content": "def test_delete_product_as_admin(db: Session, admin_user, test_product):\n    \"\"\"Test deleting product as admin\"\"\"\n    response = client.delete(\n        f\"/api/v1/products/{test_product.id}\",\n        headers=get_auth_headers(admin_user)\n    )\n    \n    assert response.status_code == 204\n    \n    # Verify product is deleted\n    get_response = client.get(f\"/api/v1/products/{test_product.id}\")\n    assert get_response.status_code == 404",
      "metadata": {
        "file_path": "tests/test_products.py",
        "chunk_type": "function",
        "name": "test_delete_product_as_admin",
        "purpose": "Test deleting product as admin",
        "dependencies": [],
        "access_level": "public",
        "function_name": "test_delete_product_as_admin",
        "parameters": [
          "db: Session",
          "admin_user",
          "test_product"
        ],
        "return_type": "",
        "decorators": [],
        "is_async": false
      },
      "description": "**Function Description: `test_delete_product_as_admin`**\n\nThe `test_delete_product_as_admin` function is a unit test designed to verify the functionality of deleting a product from an API as an admin user. It expects three parameters: a database session (`db: Session`), an admin user object (`admin_user`), and a test product object (`test_product`). \n\nUpon execution, the function sends a DELETE request to the API endpoint for the specified product using the admin user's authentication headers. It asserts that the response status code is 204, indicating successful deletion. Subsequently, it confirms that the product has been removed by sending a GET request to the same endpoint and checking for a 404 status code, which signifies that the product no longer exists.\n\nDevelopers would use this function during the testing phase of API development to ensure that the product deletion feature works correctly for admin users. It helps identify issues related to permissions and product management, ensuring that only authorized users can delete products and that the system"
    },
    {
      "type": "imports",
      "name": "module_imports",
      "content": "Module Dependencies:\n\nThird Party: pytest\n  - pytest\n\nThird Party: fastapi.testclient\n  - TestClient\n\nThird Party: sqlalchemy.orm\n  - Session\n\nThird Party: main\n  - app\n\nLocal: app.core.database\n  - get_db\n\nLocal: app.models.user\n  - User\n\nLocal: app.core.security\n  - get_password_hash",
      "metadata": {
        "file_path": "tests/test_auth.py",
        "chunk_type": "imports",
        "name": "module_imports",
        "purpose": "Module dependencies and imports",
        "dependencies": [],
        "access_level": "public",
        "imports": [
          {
            "module": "pytest",
            "type": "third_party",
            "items": [
              "pytest"
            ]
          },
          {
            "module": "fastapi.testclient",
            "type": "third_party",
            "items": [
              "TestClient"
            ]
          },
          {
            "module": "sqlalchemy.orm",
            "type": "third_party",
            "items": [
              "Session"
            ]
          },
          {
            "module": "main",
            "type": "third_party",
            "items": [
              "app"
            ]
          },
          {
            "module": "app.core.database",
            "type": "local",
            "items": [
              "get_db"
            ]
          },
          {
            "module": "app.models.user",
            "type": "local",
            "items": [
              "User"
            ]
          },
          {
            "module": "app.core.security",
            "type": "local",
            "items": [
              "get_password_hash"
            ]
          }
        ]
      },
      "description": "The `module_imports` Python module outlines its dependencies and imports essential for its functionality. It relies on several third-party libraries, including `pytest` for testing, `fastapi.testclient` for HTTP client testing, and `sqlalchemy.orm` for database session management. Additionally, it imports the main application instance from `main`, which serves as the entry point for the application.\n\nLocally, the module integrates components from the application's core and models, specifically `get_db` from `app.core.database` for database connection management, `User` from `app.models.user` for user-related data handling, and `get_password_hash` from `app.core.security` for secure password hashing.\n\nThis module is crucial for establishing the testing environment, managing database interactions, and ensuring user authentication and security within the broader FastAPI application architecture. Its use of external libraries enhances its capabilities for testing and database operations, making it a vital part of the system's infrastructure."
    },
    {
      "type": "function",
      "name": "test_user",
      "content": "def test_user(db: Session):\n    \"\"\"Create test user\"\"\"\n    user = User(\n        email=\"test@example.com\",\n        username=\"testuser\",\n        hashed_password=get_password_hash(\"testpassword\"),\n        first_name=\"Test\",\n        last_name=\"User\"\n    )\n    db.add(user)\n    db.commit()\n    db.refresh(user)\n    return user",
      "metadata": {
        "file_path": "tests/test_auth.py",
        "chunk_type": "function",
        "name": "test_user",
        "purpose": "Create test user",
        "dependencies": [],
        "access_level": "public",
        "function_name": "test_user",
        "parameters": [
          "db: Session"
        ],
        "return_type": "",
        "decorators": [
          "pytest.fixture"
        ],
        "is_async": false
      },
      "description": "**Function Description: `test_user`**\n\nThe `test_user` function is designed to create and store a test user in a database. It takes a single parameter, `db`, which is an instance of `Session` from SQLAlchemy, representing the database session used for executing operations.\n\n**Inputs:**\n- `db: Session`: A SQLAlchemy session object for database interactions.\n\n**Returns:**\n- The function returns a `User` object that represents the newly created test user, including attributes such as email, username, hashed password, first name, and last name.\n\n**Use Cases:**\nDevelopers would use this function during testing or development phases to quickly generate a predefined user in the database. This is particularly useful for unit tests or integration tests where a consistent user state is required.\n\n**Problem Solved:**\nThe function simplifies the process of creating a test user, ensuring that developers can easily set up a known user for testing purposes without manual database entries. It automates user creation"
    },
    {
      "type": "function",
      "name": "test_register_user",
      "content": "def test_register_user(db: Session):\n    \"\"\"Test user registration\"\"\"\n    response = client.post(\"/api/v1/auth/register\", json={\n        \"email\": \"newuser@example.com\",\n        \"username\": \"newuser\",\n        \"password\": \"newpassword123\",\n        \"first_name\": \"New\",\n        \"last_name\": \"User\"\n    })\n    \n    assert response.status_code == 201\n    data = response.json()\n    assert data[\"email\"] == \"newuser@example.com\"\n    assert data[\"username\"] == \"newuser\"\n    assert \"id\" in data",
      "metadata": {
        "file_path": "tests/test_auth.py",
        "chunk_type": "function",
        "name": "test_register_user",
        "purpose": "Test user registration",
        "dependencies": [],
        "access_level": "public",
        "function_name": "test_register_user",
        "parameters": [
          "db: Session"
        ],
        "return_type": "",
        "decorators": [],
        "is_async": false
      },
      "description": "**Function Description: `test_register_user`**\n\nThe `test_register_user` function is designed to validate the user registration process in a web application. It simulates a POST request to the registration endpoint (`/api/v1/auth/register`) with a predefined set of user details, including email, username, password, first name, and last name.\n\n**Inputs:**\n- `db: Session`: A database session object used for interacting with the database during the test.\n\n**Returns:**\n- The function does not return a value but asserts that the HTTP response status code is 201 (Created) and verifies that the returned JSON data contains the expected email and username, along with the presence of a user ID.\n\n**Usage Context:**\nDevelopers would use this function during unit testing to ensure that the user registration functionality works correctly and that the API responds as expected when valid data is submitted.\n\n**Problem Solved:**\nThis function helps identify issues in the user registration process, ensuring that new users"
    },
    {
      "type": "function",
      "name": "test_register_duplicate_email",
      "content": "def test_register_duplicate_email(db: Session, test_user):\n    \"\"\"Test registration with duplicate email\"\"\"\n    response = client.post(\"/api/v1/auth/register\", json={\n        \"email\": \"test@example.com\",\n        \"username\": \"differentuser\",\n        \"password\": \"password123\"\n    })\n    \n    assert response.status_code == 400\n    assert \"already exists\" in response.json()[\"detail\"]",
      "metadata": {
        "file_path": "tests/test_auth.py",
        "chunk_type": "function",
        "name": "test_register_duplicate_email",
        "purpose": "Test registration with duplicate email",
        "dependencies": [],
        "access_level": "public",
        "function_name": "test_register_duplicate_email",
        "parameters": [
          "db: Session",
          "test_user"
        ],
        "return_type": "",
        "decorators": [],
        "is_async": false
      },
      "description": "**Function Description: `test_register_duplicate_email`**\n\nThe `test_register_duplicate_email` function is a unit test designed to verify the behavior of a user registration endpoint when a duplicate email is submitted. It accepts two parameters: `db`, which is a SQLAlchemy session object for database interactions, and `test_user`, representing a user object for testing purposes. \n\nUpon execution, the function sends a POST request to the registration API with a predefined email, username, and password. It asserts that the response status code is 400, indicating a client error, and checks that the response message contains \"already exists,\" confirming that the system correctly identifies the duplicate email scenario.\n\nDevelopers would use this function during the testing phase of application development to ensure that the registration process properly handles duplicate email entries, thus preventing data integrity issues. It addresses the problem of allowing multiple accounts to be registered with the same email, which could lead to confusion and security vulnerabilities."
    },
    {
      "type": "function",
      "name": "test_login_success",
      "content": "def test_login_success(db: Session, test_user):\n    \"\"\"Test successful login\"\"\"\n    response = client.post(\"/api/v1/auth/login\", data={\n        \"username\": \"test@example.com\",\n        \"password\": \"testpassword\"\n    })\n    \n    assert response.status_code == 200\n    data = response.json()\n    assert \"access_token\" in data\n    assert data[\"token_type\"] == \"bearer\"",
      "metadata": {
        "file_path": "tests/test_auth.py",
        "chunk_type": "function",
        "name": "test_login_success",
        "purpose": "Test successful login",
        "dependencies": [],
        "access_level": "public",
        "function_name": "test_login_success",
        "parameters": [
          "db: Session",
          "test_user"
        ],
        "return_type": "",
        "decorators": [],
        "is_async": false
      },
      "description": "**Function Description: `test_login_success`**\n\nThe `test_login_success` function is designed to verify the successful login functionality of an authentication API endpoint. It accepts two parameters: a database session (`db: Session`) and a test user object (`test_user`). \n\nUpon execution, the function sends a POST request to the login endpoint (`/api/v1/auth/login`) with predefined credentials (username and password). It asserts that the HTTP response status code is 200, indicating a successful login. Additionally, it checks that the response JSON contains an \"access_token\" and that the token type is \"bearer\".\n\nDevelopers would use this function during automated testing to ensure that the login process works as expected and to confirm that valid credentials return the appropriate authentication tokens. This function helps identify issues in the login mechanism, enhancing the reliability of the authentication system."
    },
    {
      "type": "function",
      "name": "test_login_invalid_credentials",
      "content": "def test_login_invalid_credentials(db: Session, test_user):\n    \"\"\"Test login with invalid credentials\"\"\"\n    response = client.post(\"/api/v1/auth/login\", data={\n        \"username\": \"test@example.com\",\n        \"password\": \"wrongpassword\"\n    })\n    \n    assert response.status_code == 401\n    assert \"Incorrect\" in response.json()[\"detail\"]",
      "metadata": {
        "file_path": "tests/test_auth.py",
        "chunk_type": "function",
        "name": "test_login_invalid_credentials",
        "purpose": "Test login with invalid credentials",
        "dependencies": [],
        "access_level": "public",
        "function_name": "test_login_invalid_credentials",
        "parameters": [
          "db: Session",
          "test_user"
        ],
        "return_type": "",
        "decorators": [],
        "is_async": false
      },
      "description": "**Description of `test_login_invalid_credentials` Function:**\n\nThe `test_login_invalid_credentials` function is a unit test designed to validate the login functionality of an API endpoint when provided with invalid user credentials. It accepts two parameters: `db`, which is a SQLAlchemy session object for database interactions, and `test_user`, representing a user object for testing purposes. \n\nUpon execution, the function sends a POST request to the `/api/v1/auth/login` endpoint with a predefined invalid username and password. It asserts that the response status code is 401, indicating unauthorized access, and checks that the response message contains the word \"Incorrect,\" confirming the failure of the login attempt.\n\nDevelopers would use this function during the testing phase to ensure that the login system correctly handles invalid credentials, thereby enhancing the application's security and user experience. This function helps identify potential vulnerabilities by ensuring that unauthorized access is appropriately denied."
    },
    {
      "type": "function",
      "name": "test_get_current_user",
      "content": "def test_get_current_user(db: Session, test_user):\n    \"\"\"Test getting current user\"\"\"\n    # First login to get token\n    login_response = client.post(\"/api/v1/auth/login\", data={\n        \"username\": \"test@example.com\",\n        \"password\": \"testpassword\"\n    })\n    token = login_response.json()[\"access_token\"]\n    \n    # Get current user\n    response = client.get(\n        \"/api/v1/auth/me\",\n        headers={\"Authorization\": f\"Bearer {token}\"}\n    )\n    \n    assert response.status_code == 200\n    data = response.json()\n    assert data[\"email\"] == \"test@example.com\"\n    assert data[\"username\"] == \"testuser\"",
      "metadata": {
        "file_path": "tests/test_auth.py",
        "chunk_type": "function",
        "name": "test_get_current_user",
        "purpose": "Test getting current user",
        "dependencies": [],
        "access_level": "public",
        "function_name": "test_get_current_user",
        "parameters": [
          "db: Session",
          "test_user"
        ],
        "return_type": "",
        "decorators": [],
        "is_async": false
      },
      "description": "**Function Description: `test_get_current_user`**\n\nThe `test_get_current_user` function is a unit test designed to verify the functionality of retrieving the current user's information in an API. It expects two inputs: a database session object (`db: Session`) and a test user object (`test_user`). \n\nThe function performs the following steps:\n1. It simulates a user login by sending a POST request to the authentication endpoint with predefined credentials, retrieving an access token from the response.\n2. It then uses this token to send a GET request to the `/api/v1/auth/me` endpoint to fetch the current user's details.\n3. The function asserts that the response status code is 200 (indicating success) and checks that the returned user's email and username match the expected values.\n\nDevelopers would use this function during testing to ensure that the user authentication and retrieval processes are functioning correctly. It helps identify issues related to user session management and API responses, ensuring that the application behaves as expected"
    },
    {
      "type": "function",
      "name": "test_get_current_user_invalid_token",
      "content": "def test_get_current_user_invalid_token():\n    \"\"\"Test getting current user with invalid token\"\"\"\n    response = client.get(\n        \"/api/v1/auth/me\",\n        headers={\"Authorization\": \"Bearer invalid_token\"}\n    )\n    \n    assert response.status_code == 401",
      "metadata": {
        "file_path": "tests/test_auth.py",
        "chunk_type": "function",
        "name": "test_get_current_user_invalid_token",
        "purpose": "Test getting current user with invalid token",
        "dependencies": [],
        "access_level": "public",
        "function_name": "test_get_current_user_invalid_token",
        "parameters": [],
        "return_type": "",
        "decorators": [],
        "is_async": false
      },
      "description": "**Function Description: `test_get_current_user_invalid_token`**\n\nThe `test_get_current_user_invalid_token` function is a unit test designed to verify the behavior of an API endpoint when an invalid authentication token is provided. It does not accept any parameters. The function sends a GET request to the `/api/v1/auth/me` endpoint with an \"Authorization\" header containing a deliberately invalid token (\"Bearer invalid_token\"). \n\nThe expected outcome of this test is an HTTP response with a status code of 401, indicating that the request is unauthorized due to the invalid token. Developers would use this function to ensure that the authentication mechanism correctly handles invalid tokens, thereby enhancing the security and robustness of the API. This test helps identify potential vulnerabilities related to unauthorized access and ensures compliance with expected authentication protocols."
    },
    {
      "type": "imports",
      "name": "module_imports",
      "content": "Module Dependencies:\n\nStandard Library: os\n  - os\n\nStandard Library: typing\n  - List, Optional\n\nThird Party: pydantic\n  - BaseSettings, validator",
      "metadata": {
        "file_path": "app/core/config.py",
        "chunk_type": "imports",
        "name": "module_imports",
        "purpose": "Module dependencies and imports",
        "dependencies": [],
        "access_level": "public",
        "imports": [
          {
            "module": "os",
            "type": "standard",
            "items": [
              "os"
            ]
          },
          {
            "module": "typing",
            "type": "standard",
            "items": [
              "List",
              "Optional"
            ]
          },
          {
            "module": "pydantic",
            "type": "third_party",
            "items": [
              "BaseSettings",
              "validator"
            ]
          }
        ]
      },
      "description": "The `module_imports` Python module manages its dependencies and imports essential libraries for its functionality. It relies on the standard library modules `os` for operating system interactions and `typing` for type hinting, specifically utilizing `List` and `Optional` to enhance code clarity and type safety. Additionally, it incorporates the third-party library `pydantic`, leveraging `BaseSettings` for configuration management and `validator` for data validation. This module serves as a foundational component in the system, ensuring robust handling of configurations and type checks while integrating seamlessly with both standard and external libraries."
    },
    {
      "type": "class",
      "name": "Settings",
      "content": "class Settings:\n    # Inherits from: BaseSettings\n    # Purpose: Application settings\n\n    def assemble_cors_origins(self, ...):\n        # Method implementation",
      "metadata": {
        "file_path": "app/core/config.py",
        "chunk_type": "class",
        "name": "Settings",
        "purpose": "Application settings",
        "dependencies": [],
        "access_level": "public",
        "class_name": "Settings",
        "methods": [
          "assemble_cors_origins"
        ],
        "attributes": [],
        "base_classes": [
          "BaseSettings"
        ],
        "decorators": []
      },
      "description": "**Description:**\n\nThe `Settings` class represents application configuration settings, specifically designed to manage Cross-Origin Resource Sharing (CORS) origins. Inheriting from `BaseSettings`, it provides a structured way to define and retrieve application settings, ensuring consistency and ease of management. \n\nThe primary method, `assemble_cors_origins`, is responsible for compiling a list of allowed CORS origins, addressing security and access control issues when handling requests from different domains. Developers would utilize this class when building web applications that require precise control over which external domains can interact with their APIs, enhancing security and compliance with web standards.\n\nThis class fits into the system as a foundational component for configuration management, enabling seamless integration of CORS settings into the overall application architecture, thereby facilitating secure cross-domain interactions."
    },
    {
      "type": "class",
      "name": "Config",
      "content": "class Config:\n    # Purpose: No description available",
      "metadata": {
        "file_path": "app/core/config.py",
        "chunk_type": "class",
        "name": "Config",
        "purpose": "Class Config",
        "dependencies": [],
        "access_level": "public",
        "class_name": "Config",
        "methods": [],
        "attributes": [],
        "base_classes": [],
        "decorators": []
      },
      "description": "**Class Description: Config**\n\nThe `Config` class serves as a placeholder for configuration settings within a software application. Although it does not currently contain any methods or attributes, it is designed to encapsulate configuration-related data, providing a structured way to manage application settings. Developers would use this class when they need a centralized location to define and access configuration parameters, which can enhance code maintainability and readability. As the application evolves, the `Config` class can be expanded to include methods for loading, validating, and updating configuration values, thereby solving the problem of scattered configuration logic. It fits into the system as a foundational component that can support various modules requiring configuration management."
    },
    {
      "type": "function",
      "name": "assemble_cors_origins",
      "content": "    def assemble_cors_origins(cls, v):\n        if isinstance(v, str):\n            return [i.strip() for i in v.split(\",\")]\n        return v",
      "metadata": {
        "file_path": "app/core/config.py",
        "chunk_type": "function",
        "name": "assemble_cors_origins",
        "purpose": "Function assemble_cors_origins",
        "dependencies": [],
        "access_level": "public",
        "function_name": "assemble_cors_origins",
        "parameters": [
          "cls",
          "v"
        ],
        "return_type": "",
        "decorators": [
          "validator('ALLOWED_HOSTS', pre=True)"
        ],
        "is_async": false
      },
      "description": "**Function Description: `assemble_cors_origins`**\n\nThe `assemble_cors_origins` function processes and formats Cross-Origin Resource Sharing (CORS) origins. It accepts two parameters: `cls`, which is typically a reference to the class (not utilized in the function), and `v`, which can be either a string or a list. \n\n- **Input:** The function expects `v` to be a comma-separated string of origins or a list of origins.\n- **Output:** It returns a list of origins, where each origin is stripped of leading and trailing whitespace. If `v` is already a list, it returns it unchanged.\n- **Use Case:** Developers would use this function when configuring CORS settings in web applications to ensure that origins are correctly formatted for security and functionality.\n- **Problem Solved:** It helps in standardizing the input of CORS origins, making it easier to handle and validate them, thus preventing potential errors in web application security configurations."
    },
    {
      "type": "imports",
      "name": "module_imports",
      "content": "Module Dependencies:\n\nThird Party: sqlalchemy\n  - create_engine, MetaData\n\nThird Party: sqlalchemy.ext.declarative\n  - declarative_base\n\nThird Party: sqlalchemy.orm\n  - sessionmaker, Session\n\nThird Party: sqlalchemy.pool\n  - StaticPool\n\nLocal: app.core.config\n  - settings\n\nLocal: app.models\n  - user, product, order, category",
      "metadata": {
        "file_path": "app/core/database.py",
        "chunk_type": "imports",
        "name": "module_imports",
        "purpose": "Module dependencies and imports",
        "dependencies": [],
        "access_level": "public",
        "imports": [
          {
            "module": "sqlalchemy",
            "type": "third_party",
            "items": [
              "create_engine",
              "MetaData"
            ]
          },
          {
            "module": "sqlalchemy.ext.declarative",
            "type": "third_party",
            "items": [
              "declarative_base"
            ]
          },
          {
            "module": "sqlalchemy.orm",
            "type": "third_party",
            "items": [
              "sessionmaker",
              "Session"
            ]
          },
          {
            "module": "sqlalchemy.pool",
            "type": "third_party",
            "items": [
              "StaticPool"
            ]
          },
          {
            "module": "app.core.config",
            "type": "local",
            "items": [
              "settings"
            ]
          },
          {
            "module": "app.models",
            "type": "local",
            "items": [
              "user",
              "product",
              "order",
              "category"
            ]
          }
        ]
      },
      "description": "The `module_imports` Python module manages dependencies and imports essential for database interaction and application configuration. It utilizes the third-party library SQLAlchemy, which provides robust ORM capabilities, including:\n\n- **`create_engine`** and **`MetaData`** from `sqlalchemy` for database connection management and schema representation.\n- **`declarative_base`** from `sqlalchemy.ext.declarative` to facilitate the creation of ORM models.\n- **`sessionmaker`** and **`Session`** from `sqlalchemy.orm` for session management, enabling transactions and data manipulation.\n- **`StaticPool`** from `sqlalchemy.pool` to optimize database connection pooling.\n\nAdditionally, it imports local modules from the application, specifically:\n\n- **`settings`** from `app.core.config` for application configuration settings.\n- **`user`**, **`product`**, **`order`**, and **`category`** from `app.models` to define the data structures and"
    },
    {
      "type": "function",
      "name": "get_db",
      "content": "def get_db() -> Session:\n    \"\"\"Get database session\"\"\"\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()",
      "metadata": {
        "file_path": "app/core/database.py",
        "chunk_type": "function",
        "name": "get_db",
        "purpose": "Get database session",
        "dependencies": [],
        "access_level": "public",
        "function_name": "get_db",
        "parameters": [],
        "return_type": "Session",
        "decorators": [],
        "is_async": false
      },
      "description": "**Description of the `get_db` Function:**\n\nThe `get_db` function is designed to provide a database session for use in applications that require database interactions. It does not accept any parameters. The function utilizes a context manager to yield a session instance created by `SessionLocal()`, allowing developers to perform database operations within a controlled environment. Once the operations are complete, the session is automatically closed to free up resources.\n\nDevelopers would use this function in scenarios where a temporary database session is needed, such as in web applications or API endpoints that require database access. It effectively manages the lifecycle of the database session, ensuring that sessions are properly opened and closed, which helps prevent resource leaks and connection issues. \n\nIn summary, `get_db` simplifies database session management, enhances code readability, and promotes best practices in resource handling within database-driven applications."
    },
    {
      "type": "function",
      "name": "get_db_session",
      "content": "def get_db_session() -> Session:\n    \"\"\"Get database session for direct use\"\"\"\n    return SessionLocal()",
      "metadata": {
        "file_path": "app/core/database.py",
        "chunk_type": "function",
        "name": "get_db_session",
        "purpose": "Get database session for direct use",
        "dependencies": [],
        "access_level": "public",
        "function_name": "get_db_session",
        "parameters": [],
        "return_type": "Session",
        "decorators": [],
        "is_async": false
      },
      "description": "**Description of `get_db_session` Function:**\n\nThe `get_db_session` function is designed to provide a database session for direct interaction with the database. It does not accept any parameters and returns an instance of `Session`, which is typically used for executing database operations. Developers would use this function when they need to establish a connection to the database for tasks such as querying, inserting, or updating records. It simplifies the process of obtaining a session by encapsulating the session creation logic, thereby solving the problem of managing database connections efficiently and reducing boilerplate code in database-related operations."
    },
    {
      "type": "imports",
      "name": "module_imports",
      "content": "Module Dependencies:\n\nStandard Library: datetime\n  - datetime, timedelta\n\nStandard Library: typing\n  - Optional, Union\n\nThird Party: jose\n  - JWTError, jwt\n\nThird Party: passlib.context\n  - CryptContext\n\nThird Party: fastapi\n  - HTTPException, status\n\nLocal: app.core.config\n  - settings",
      "metadata": {
        "file_path": "app/core/security.py",
        "chunk_type": "imports",
        "name": "module_imports",
        "purpose": "Module dependencies and imports",
        "dependencies": [],
        "access_level": "public",
        "imports": [
          {
            "module": "datetime",
            "type": "standard",
            "items": [
              "datetime",
              "timedelta"
            ]
          },
          {
            "module": "typing",
            "type": "standard",
            "items": [
              "Optional",
              "Union"
            ]
          },
          {
            "module": "jose",
            "type": "third_party",
            "items": [
              "JWTError",
              "jwt"
            ]
          },
          {
            "module": "passlib.context",
            "type": "third_party",
            "items": [
              "CryptContext"
            ]
          },
          {
            "module": "fastapi",
            "type": "third_party",
            "items": [
              "HTTPException",
              "status"
            ]
          },
          {
            "module": "app.core.config",
            "type": "local",
            "items": [
              "settings"
            ]
          }
        ]
      },
      "description": "The `module_imports` Python module manages various dependencies essential for its functionality. It relies on the standard library for date and time manipulation (`datetime` and `timedelta`) and type hinting (`Optional` and `Union` from `typing`). The module utilizes third-party libraries, including `jose` for handling JSON Web Tokens (JWT) with classes like `JWTError` and `jwt`, `passlib.context` for password hashing and verification through `CryptContext`, and `fastapi` for web application development, specifically using `HTTPException` and `status` for error handling and response management. Additionally, it imports local configuration settings from `app.core.config`. This module serves as a foundational component in the system, integrating essential functionalities for authentication, error management, and configuration, while leveraging both standard and external libraries for enhanced capabilities."
    },
    {
      "type": "function",
      "name": "verify_password",
      "content": "def verify_password(plain_password: str, hashed_password: str) -> bool:\n    \"\"\"Verify a password against its hash\"\"\"\n    return pwd_context.verify(plain_password, hashed_password)",
      "metadata": {
        "file_path": "app/core/security.py",
        "chunk_type": "function",
        "name": "verify_password",
        "purpose": "Verify a password against its hash",
        "dependencies": [],
        "access_level": "public",
        "function_name": "verify_password",
        "parameters": [
          "plain_password: str",
          "hashed_password: str"
        ],
        "return_type": "bool",
        "decorators": [],
        "is_async": false
      },
      "description": "**Function Description: `verify_password`**\n\nThe `verify_password` function is designed to authenticate a user's input password by comparing it to a stored hashed password. It takes two parameters: `plain_password`, a string representing the user's input password, and `hashed_password`, a string representing the securely stored hash of the correct password. The function returns a boolean value`True` if the input password matches the hash, and `False` otherwise.\n\nDevelopers typically use this function during user authentication processes, such as login systems, to ensure that the provided password is correct without exposing the actual password. It addresses security concerns by preventing direct password comparison and safeguarding sensitive data through hashing."
    },
    {
      "type": "function",
      "name": "get_password_hash",
      "content": "def get_password_hash(password: str) -> str:\n    \"\"\"Hash a password\"\"\"\n    return pwd_context.hash(password)",
      "metadata": {
        "file_path": "app/core/security.py",
        "chunk_type": "function",
        "name": "get_password_hash",
        "purpose": "Hash a password",
        "dependencies": [],
        "access_level": "public",
        "function_name": "get_password_hash",
        "parameters": [
          "password: str"
        ],
        "return_type": "str",
        "decorators": [],
        "is_async": false
      },
      "description": "The `get_password_hash` function is designed to securely hash a given password using a specified hashing algorithm. It accepts a single parameter, `password`, which is a string representing the user's password. The function returns a hashed string that can be safely stored in a database. Developers would use this function when implementing user authentication systems to ensure that passwords are not stored in plain text, thereby enhancing security. By hashing passwords, it mitigates the risk of unauthorized access in case of a data breach, ensuring that even if the database is compromised, the actual passwords remain protected."
    },
    {
      "type": "function",
      "name": "create_access_token",
      "content": "def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:\n    \"\"\"Create JWT access token\"\"\"\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)\n    \n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)\n    return encoded_jwt",
      "metadata": {
        "file_path": "app/core/security.py",
        "chunk_type": "function",
        "name": "create_access_token",
        "purpose": "Create JWT access token",
        "dependencies": [],
        "access_level": "public",
        "function_name": "create_access_token",
        "parameters": [
          "data: dict",
          "expires_delta: Optional[timedelta]"
        ],
        "return_type": "str",
        "decorators": [],
        "is_async": false
      },
      "description": "The `create_access_token` function generates a JSON Web Token (JWT) for user authentication. It accepts two parameters: `data`, a dictionary containing user information, and an optional `expires_delta`, which specifies the token's expiration duration as a `timedelta` object. If `expires_delta` is not provided, the function defaults to a predefined expiration time based on application settings.\n\nThe function returns a string representing the encoded JWT, which includes the provided data along with an expiration timestamp. Developers typically use this function in web applications to issue access tokens for secure API authentication, ensuring that users can access protected resources. By creating a time-limited token, it enhances security by mitigating risks associated with long-lived credentials."
    },
    {
      "type": "function",
      "name": "verify_token",
      "content": "def verify_token(token: str) -> Optional[dict]:\n    \"\"\"Verify and decode JWT token\"\"\"\n    try:\n        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])\n        return payload\n    except JWTError:\n        return None",
      "metadata": {
        "file_path": "app/core/security.py",
        "chunk_type": "function",
        "name": "verify_token",
        "purpose": "Verify and decode JWT token",
        "dependencies": [],
        "access_level": "public",
        "function_name": "verify_token",
        "parameters": [
          "token: str"
        ],
        "return_type": "Optional[dict]",
        "decorators": [],
        "is_async": false
      },
      "description": "The `verify_token` function is designed to verify and decode a JSON Web Token (JWT). It takes a single input parameter, `token`, which is a string representing the JWT to be verified. The function attempts to decode the token using a secret key and a specified algorithm from the application settings. If the token is valid, it returns the decoded payload as a dictionary. If the token is invalid or an error occurs during decoding, it returns `None`. Developers would use this function in authentication and authorization processes to ensure the integrity and validity of JWTs, effectively solving issues related to token verification and security in web applications."
    },
    {
      "type": "function",
      "name": "get_current_user_id",
      "content": "def get_current_user_id(token: str) -> Optional[int]:\n    \"\"\"Get current user ID from token\"\"\"\n    payload = verify_token(token)\n    if payload is None:\n        return None\n    return payload.get(\"sub\")",
      "metadata": {
        "file_path": "app/core/security.py",
        "chunk_type": "function",
        "name": "get_current_user_id",
        "purpose": "Get current user ID from token",
        "dependencies": [],
        "access_level": "public",
        "function_name": "get_current_user_id",
        "parameters": [
          "token: str"
        ],
        "return_type": "Optional[int]",
        "decorators": [],
        "is_async": false
      },
      "description": "The `get_current_user_id` function retrieves the current user's ID from a provided authentication token. It accepts a single parameter, `token`, which is a string representing the user's token. The function verifies the token using the `verify_token` utility, returning `None` if the token is invalid or expired. If the token is valid, it extracts and returns the user ID from the token's payload, specifically the \"sub\" field. Developers would use this function in scenarios where user identification is required after authentication, such as in web applications or APIs. It addresses the problem of securely obtaining user information from tokens, ensuring that only valid tokens yield user IDs."
    },
    {
      "type": "function",
      "name": "require_auth",
      "content": "def require_auth(token: str) -> int:\n    \"\"\"Require valid authentication and return user ID\"\"\"\n    user_id = get_current_user_id(token)\n    if user_id is None:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Could not validate credentials\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n    return user_id",
      "metadata": {
        "file_path": "app/core/security.py",
        "chunk_type": "function",
        "name": "require_auth",
        "purpose": "Require valid authentication and return user ID",
        "dependencies": [],
        "access_level": "public",
        "function_name": "require_auth",
        "parameters": [
          "token: str"
        ],
        "return_type": "int",
        "decorators": [],
        "is_async": false
      },
      "description": "The `require_auth` function is a Python utility designed to enforce authentication by validating a provided token. It accepts a single parameter, `token`, which is a string representing the user's authentication token. The function retrieves the current user's ID associated with the token using the `get_current_user_id` function. If the token is invalid or the user ID cannot be determined, it raises an `HTTPException` with a 401 Unauthorized status, indicating that credentials could not be validated. \n\nThis function is typically used in web applications and APIs where secure access to resources is required, ensuring that only authenticated users can proceed. By implementing this function, developers can effectively manage user authentication, enhance security, and prevent unauthorized access to sensitive operations or data."
    },
    {
      "type": "imports",
      "name": "module_imports",
      "content": "Module Dependencies:\n\nStandard Library: re\n  - re\n\nStandard Library: typing\n  - Optional\n\nThird Party: decimal\n  - Decimal",
      "metadata": {
        "file_path": "app/utils/validators.py",
        "chunk_type": "imports",
        "name": "module_imports",
        "purpose": "Module dependencies and imports",
        "dependencies": [],
        "access_level": "public",
        "imports": [
          {
            "module": "re",
            "type": "standard",
            "items": [
              "re"
            ]
          },
          {
            "module": "typing",
            "type": "standard",
            "items": [
              "Optional"
            ]
          },
          {
            "module": "decimal",
            "type": "third_party",
            "items": [
              "Decimal"
            ]
          }
        ]
      },
      "description": "The `module_imports` Python module manages its dependencies and imports essential libraries for its functionality. It utilizes the standard library's `re` module for regular expression operations, enabling pattern matching and string manipulation. Additionally, it imports `Optional` from the `typing` module, which facilitates type hinting and enhances code readability by allowing optional type annotations.\n\nFor numerical operations, the module incorporates the third-party `decimal` library, specifically the `Decimal` class, which provides precise decimal arithmetic, crucial for financial calculations and scenarios requiring high precision.\n\nOverall, `module_imports` serves as a foundational component within a larger system, leveraging both standard and external libraries to ensure robust functionality and maintainability in handling string patterns and precise numerical data."
    },
    {
      "type": "function",
      "name": "validate_email",
      "content": "def validate_email(email: str) -> bool:\n    \"\"\"Validate email format\"\"\"\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return re.match(pattern, email) is not None",
      "metadata": {
        "file_path": "app/utils/validators.py",
        "chunk_type": "function",
        "name": "validate_email",
        "purpose": "Validate email format",
        "dependencies": [],
        "access_level": "public",
        "function_name": "validate_email",
        "parameters": [
          "email: str"
        ],
        "return_type": "bool",
        "decorators": [],
        "is_async": false
      },
      "description": "The `validate_email` function is designed to verify the format of an email address in Python. It accepts a single parameter, `email`, which is a string representing the email address to be validated. The function uses a regular expression pattern to check if the provided email conforms to standard email formatting rules. It returns a boolean value: `True` if the email format is valid and `False` otherwise. Developers would use this function when implementing user registration forms, login systems, or any feature requiring email input validation. It helps prevent errors related to incorrect email formats, enhancing data integrity and user experience."
    },
    {
      "type": "function",
      "name": "validate_phone",
      "content": "def validate_phone(phone: str) -> bool:\n    \"\"\"Validate phone number format\"\"\"\n    # Remove all non-digit characters\n    digits_only = re.sub(r'\\D', '', phone)\n    # Check if it's a valid length (7-15 digits)\n    return 7 <= len(digits_only) <= 15",
      "metadata": {
        "file_path": "app/utils/validators.py",
        "chunk_type": "function",
        "name": "validate_phone",
        "purpose": "Validate phone number format",
        "dependencies": [],
        "access_level": "public",
        "function_name": "validate_phone",
        "parameters": [
          "phone: str"
        ],
        "return_type": "bool",
        "decorators": [],
        "is_async": false
      },
      "description": "**Function Description: validate_phone**\n\nThe `validate_phone` function is designed to validate the format of phone numbers. It takes a single input parameter, `phone`, which is expected to be a string representing a phone number. The function processes this input by removing all non-digit characters and then checks if the resulting string contains between 7 and 15 digits. \n\nThe function returns a boolean value: `True` if the phone number meets the length criteria, and `False` otherwise. Developers would use this function when they need to ensure that user-provided phone numbers conform to a standard format, particularly in applications involving user registration, contact forms, or any system that requires valid phone number input. \n\nThis function addresses common issues related to phone number validation, such as filtering out invalid characters and enforcing length constraints, thereby improving data integrity and user experience."
    },
    {
      "type": "function",
      "name": "validate_password_strength",
      "content": "def validate_password_strength(password: str) -> tuple[bool, str]:\n    \"\"\"Validate password strength\"\"\"\n    if len(password) < 8:\n        return False, \"Password must be at least 8 characters long\"\n    \n    if not re.search(r'[A-Z]', password):\n        return False, \"Password must contain at least one uppercase letter\"\n    \n    if not re.search(r'[a-z]', password):\n        return False, \"Password must contain at least one lowercase letter\"\n    \n    if not re.search(r'\\d', password):\n        return False, \"Password must contain at least one digit\"\n    \n    if not re.search(r'[!@#$%^&*(),.?\":{}|<>]', password):\n        return False, \"Password must contain at least one special character\"\n    \n    return True, \"Password is strong\"",
      "metadata": {
        "file_path": "app/utils/validators.py",
        "chunk_type": "function",
        "name": "validate_password_strength",
        "purpose": "Validate password strength",
        "dependencies": [],
        "access_level": "public",
        "function_name": "validate_password_strength",
        "parameters": [
          "password: str"
        ],
        "return_type": "tuple[bool, str]",
        "decorators": [],
        "is_async": false
      },
      "description": "**Function Description: validate_password_strength**\n\nThe `validate_password_strength` function is designed to assess the strength of a given password based on specific criteria. It accepts a single input parameter, `password`, which is a string representing the password to be validated. \n\nThis function checks for the following conditions:\n1. Minimum length of 8 characters.\n2. Presence of at least one uppercase letter.\n3. Presence of at least one lowercase letter.\n4. Inclusion of at least one digit.\n5. Inclusion of at least one special character from a defined set.\n\nUpon evaluation, the function returns a tuple containing a boolean value and a message string. If the password meets all criteria, it returns `(True, \"Password is strong\")`. If any criteria are not met, it returns `(False, \"Error message\")` indicating the specific requirement that was not satisfied.\n\nDevelopers would use this function when implementing user authentication systems to ensure that users create secure passwords, thereby enhancing security and reducing the risk of"
    },
    {
      "type": "function",
      "name": "validate_sku",
      "content": "def validate_sku(sku: str) -> bool:\n    \"\"\"Validate product SKU format\"\"\"\n    # SKU should be alphanumeric with optional hyphens/underscores\n    pattern = r'^[A-Z0-9-_]+$'\n    return re.match(pattern, sku) is not None",
      "metadata": {
        "file_path": "app/utils/validators.py",
        "chunk_type": "function",
        "name": "validate_sku",
        "purpose": "Validate product SKU format",
        "dependencies": [],
        "access_level": "public",
        "function_name": "validate_sku",
        "parameters": [
          "sku: str"
        ],
        "return_type": "bool",
        "decorators": [],
        "is_async": false
      },
      "description": "The `validate_sku` function is designed to validate the format of a product Stock Keeping Unit (SKU). It expects a single input parameter, `sku`, which should be a string representing the SKU to be validated. The function checks if the SKU is alphanumeric and may include optional hyphens or underscores, using a regular expression pattern. It returns a boolean value: `True` if the SKU format is valid and `False` otherwise. Developers would use this function when implementing inventory management systems or e-commerce platforms to ensure that SKUs conform to specified formatting rules, thereby preventing errors in product identification and tracking. This function effectively addresses the problem of invalid SKU formats, enhancing data integrity and consistency in product databases."
    },
    {
      "type": "function",
      "name": "validate_price",
      "content": "def validate_price(price: Decimal) -> bool:\n    \"\"\"Validate price value\"\"\"\n    return price > 0 and price <= Decimal('999999.99')",
      "metadata": {
        "file_path": "app/utils/validators.py",
        "chunk_type": "function",
        "name": "validate_price",
        "purpose": "Validate price value",
        "dependencies": [],
        "access_level": "public",
        "function_name": "validate_price",
        "parameters": [
          "price: Decimal"
        ],
        "return_type": "bool",
        "decorators": [],
        "is_async": false
      },
      "description": "**Function Description: validate_price**\n\nThe `validate_price` function is designed to validate a price value represented as a `Decimal`. It accepts a single parameter, `price`, which must be a `Decimal` type. The function checks if the price is greater than 0 and less than or equal to 999,999.99. It returns a boolean value: `True` if the price is valid according to these criteria, and `False` otherwise.\n\nDevelopers would use this function in scenarios where price validation is crucial, such as e-commerce applications, financial systems, or any context where accurate pricing is necessary. It helps prevent invalid price entries that could lead to errors in transactions, reporting, or user experience, ensuring that only acceptable price values are processed."
    },
    {
      "type": "function",
      "name": "validate_stock_quantity",
      "content": "def validate_stock_quantity(quantity: int) -> bool:\n    \"\"\"Validate stock quantity\"\"\"\n    return 0 <= quantity <= 999999",
      "metadata": {
        "file_path": "app/utils/validators.py",
        "chunk_type": "function",
        "name": "validate_stock_quantity",
        "purpose": "Validate stock quantity",
        "dependencies": [],
        "access_level": "public",
        "function_name": "validate_stock_quantity",
        "parameters": [
          "quantity: int"
        ],
        "return_type": "bool",
        "decorators": [],
        "is_async": false
      },
      "description": "The `validate_stock_quantity` function in Python is designed to validate stock quantities for inventory management. It accepts a single parameter, `quantity`, which is expected to be an integer. The function checks if the provided quantity falls within the acceptable range of 0 to 999,999, inclusive. It returns a boolean value: `True` if the quantity is valid, and `False` otherwise. Developers would use this function when implementing inventory systems to ensure that stock levels are within permissible limits, thereby preventing errors related to negative or excessively high stock values. This function helps maintain data integrity and supports effective inventory control."
    },
    {
      "type": "function",
      "name": "validate_dimensions",
      "content": "def validate_dimensions(dimensions: str) -> bool:\n    \"\"\"Validate product dimensions format (LxWxH)\"\"\"\n    pattern = r'^\\d+(\\.\\d+)?x\\d+(\\.\\d+)?x\\d+(\\.\\d+)?$'\n    return re.match(pattern, dimensions) is not None",
      "metadata": {
        "file_path": "app/utils/validators.py",
        "chunk_type": "function",
        "name": "validate_dimensions",
        "purpose": "Validate product dimensions format (LxWxH)",
        "dependencies": [],
        "access_level": "public",
        "function_name": "validate_dimensions",
        "parameters": [
          "dimensions: str"
        ],
        "return_type": "bool",
        "decorators": [],
        "is_async": false
      },
      "description": "**Function Description: validate_dimensions**\n\nThe `validate_dimensions` function is designed to verify the format of product dimensions specified as a string in the format \"LxWxH\" (Length x Width x Height). It takes a single parameter, `dimensions`, which is expected to be a string representing the dimensions of a product. The function utilizes a regular expression to check if the input string adheres to the specified format, allowing for both integer and decimal values.\n\n**Inputs:** \n- `dimensions: str` - A string representing product dimensions in the format \"LxWxH\".\n\n**Returns:** \n- `bool` - Returns `True` if the input string matches the required format, otherwise returns `False`.\n\n**Use Cases:** \nDevelopers would use this function in applications where validating product specifications is crucial, such as e-commerce platforms, inventory management systems, or any software that requires accurate product dimension entries.\n\n**Problem Solved:** \nThis function helps prevent errors related to incorrect dimension formats"
    },
    {
      "type": "function",
      "name": "sanitize_string",
      "content": "def sanitize_string(value: str) -> str:\n    \"\"\"Sanitize string input\"\"\"\n    # Remove leading/trailing whitespace\n    value = value.strip()\n    # Replace multiple spaces with single space\n    value = re.sub(r'\\s+', ' ', value)\n    return value",
      "metadata": {
        "file_path": "app/utils/validators.py",
        "chunk_type": "function",
        "name": "sanitize_string",
        "purpose": "Sanitize string input",
        "dependencies": [],
        "access_level": "public",
        "function_name": "sanitize_string",
        "parameters": [
          "value: str"
        ],
        "return_type": "str",
        "decorators": [],
        "is_async": false
      },
      "description": "The `sanitize_string` function is designed to clean and normalize string input by removing unnecessary whitespace. It accepts a single parameter, `value`, which is expected to be a string (`str`). The function processes the input by trimming leading and trailing whitespace and replacing any sequence of multiple spaces with a single space. It returns the sanitized string. Developers would use this function when they need to ensure consistent formatting of user input or data, particularly in scenarios involving text processing, data entry validation, or preparing strings for storage or display. This function effectively solves issues related to inconsistent spacing, which can lead to errors in data handling or presentation."
    },
    {
      "type": "function",
      "name": "validate_slug",
      "content": "def validate_slug(slug: str) -> bool:\n    \"\"\"Validate URL slug format\"\"\"\n    pattern = r'^[a-z0-9]+(?:-[a-z0-9]+)*$'\n    return re.match(pattern, slug) is not None",
      "metadata": {
        "file_path": "app/utils/validators.py",
        "chunk_type": "function",
        "name": "validate_slug",
        "purpose": "Validate URL slug format",
        "dependencies": [],
        "access_level": "public",
        "function_name": "validate_slug",
        "parameters": [
          "slug: str"
        ],
        "return_type": "bool",
        "decorators": [],
        "is_async": false
      },
      "description": "The `validate_slug` function is designed to validate the format of a URL slug, ensuring it adheres to specific criteria. It accepts a single input parameter, `slug`, which is a string representing the slug to be validated. The function uses a regular expression pattern to check if the slug consists of lowercase alphanumeric characters and hyphens, without starting or ending with a hyphen. It returns a boolean value: `True` if the slug is valid and `False` otherwise. Developers would use this function when creating user-friendly URLs, ensuring slugs are SEO-friendly and comply with web standards. It solves the problem of invalid slug formats that could lead to broken links or poor user experience."
    },
    {
      "type": "function",
      "name": "generate_slug",
      "content": "def generate_slug(text: str) -> str:\n    \"\"\"Generate URL slug from text\"\"\"\n    # Convert to lowercase\n    slug = text.lower()\n    # Replace spaces and special characters with hyphens\n    slug = re.sub(r'[^a-z0-9]+', '-', slug)\n    # Remove leading/trailing hyphens\n    slug = slug.strip('-')\n    # Remove multiple consecutive hyphens\n    slug = re.sub(r'-+', '-', slug)\n    return slug",
      "metadata": {
        "file_path": "app/utils/validators.py",
        "chunk_type": "function",
        "name": "generate_slug",
        "purpose": "Generate URL slug from text",
        "dependencies": [],
        "access_level": "public",
        "function_name": "generate_slug",
        "parameters": [
          "text: str"
        ],
        "return_type": "str",
        "decorators": [],
        "is_async": false
      },
      "description": "**Description of `generate_slug` Function:**\n\nThe `generate_slug` function in Python is designed to create a URL-friendly slug from a given text string. It takes a single parameter, `text`, which is expected to be a string. The function processes the input by converting it to lowercase, replacing spaces and special characters with hyphens, and ensuring that the resulting slug does not have leading or trailing hyphens or multiple consecutive hyphens. The output is a clean, formatted string suitable for use in URLs.\n\nDevelopers would use this function when they need to generate slugs for web pages, blog posts, or any content that requires a readable and SEO-friendly URL format. It effectively addresses issues related to URL formatting, ensuring that the slugs are consistent, easy to read, and compliant with web standards."
    },
    {
      "type": "imports",
      "name": "module_imports",
      "content": "Module Dependencies:\n\nThird Party: uuid\n  - uuid\n\nThird Party: hashlib\n  - hashlib\n\nStandard Library: datetime\n  - datetime, timedelta\n\nStandard Library: typing\n  - Any, Dict, List, Optional\n\nThird Party: decimal\n  - Decimal",
      "metadata": {
        "file_path": "app/utils/helpers.py",
        "chunk_type": "imports",
        "name": "module_imports",
        "purpose": "Module dependencies and imports",
        "dependencies": [],
        "access_level": "public",
        "imports": [
          {
            "module": "uuid",
            "type": "third_party",
            "items": [
              "uuid"
            ]
          },
          {
            "module": "hashlib",
            "type": "third_party",
            "items": [
              "hashlib"
            ]
          },
          {
            "module": "datetime",
            "type": "standard",
            "items": [
              "datetime",
              "timedelta"
            ]
          },
          {
            "module": "typing",
            "type": "standard",
            "items": [
              "Any",
              "Dict",
              "List",
              "Optional"
            ]
          },
          {
            "module": "decimal",
            "type": "third_party",
            "items": [
              "Decimal"
            ]
          }
        ]
      },
      "description": "The `module_imports` Python module manages various dependencies essential for its functionality. It incorporates third-party libraries such as `uuid` for generating universally unique identifiers, `hashlib` for secure hash functions, and `decimal` for precise decimal arithmetic. Additionally, it utilizes standard library components, including `datetime` and `timedelta` for date and time manipulation, as well as `typing` for type hinting with constructs like `Any`, `Dict`, `List`, and `Optional`. This module serves as a foundational component within the system, enabling robust data handling and type safety while leveraging external libraries to enhance its capabilities."
    },
    {
      "type": "function",
      "name": "generate_uuid",
      "content": "def generate_uuid() -> str:\n    \"\"\"Generate a UUID string\"\"\"\n    return str(uuid.uuid4())",
      "metadata": {
        "file_path": "app/utils/helpers.py",
        "chunk_type": "function",
        "name": "generate_uuid",
        "purpose": "Generate a UUID string",
        "dependencies": [],
        "access_level": "public",
        "function_name": "generate_uuid",
        "parameters": [],
        "return_type": "str",
        "decorators": [],
        "is_async": false
      },
      "description": "**Description of the `generate_uuid` Function:**\n\nThe `generate_uuid` function generates a universally unique identifier (UUID) in string format. It does not accept any parameters and returns a string representation of a randomly generated UUID using Python's `uuid` module. Developers typically use this function when they need to create unique identifiers for database entries, session tokens, or any scenario requiring distinct identification to avoid collisions. This function effectively solves the problem of generating unique keys or identifiers, ensuring that each generated UUID is statistically unlikely to be duplicated."
    },
    {
      "type": "function",
      "name": "generate_short_id",
      "content": "def generate_short_id(length: int = 8) -> str:\n    \"\"\"Generate a short random ID\"\"\"\n    return uuid.uuid4().hex[:length].upper()",
      "metadata": {
        "file_path": "app/utils/helpers.py",
        "chunk_type": "function",
        "name": "generate_short_id",
        "purpose": "Generate a short random ID",
        "dependencies": [],
        "access_level": "public",
        "function_name": "generate_short_id",
        "parameters": [
          "length: int"
        ],
        "return_type": "str",
        "decorators": [],
        "is_async": false
      },
      "description": "**Description of `generate_short_id` Function:**\n\nThe `generate_short_id` function creates a short, random identifier using the UUID (Universally Unique Identifier) standard. It accepts a single parameter, `length`, which is an integer specifying the desired length of the generated ID, defaulting to 8 characters. The function returns a string that consists of a randomly generated hexadecimal ID, truncated to the specified length and converted to uppercase. \n\nDevelopers would use this function when they need unique identifiers for objects, sessions, or transactions where brevity is essential, such as in URLs or database keys. It solves the problem of generating unique, human-readable identifiers while ensuring a low probability of collision, making it suitable for applications requiring quick reference or tracking."
    },
    {
      "type": "function",
      "name": "generate_hash",
      "content": "def generate_hash(data: str) -> str:\n    \"\"\"Generate SHA-256 hash of data\"\"\"\n    return hashlib.sha256(data.encode()).hexdigest()",
      "metadata": {
        "file_path": "app/utils/helpers.py",
        "chunk_type": "function",
        "name": "generate_hash",
        "purpose": "Generate SHA-256 hash of data",
        "dependencies": [],
        "access_level": "public",
        "function_name": "generate_hash",
        "parameters": [
          "data: str"
        ],
        "return_type": "str",
        "decorators": [],
        "is_async": false
      },
      "description": "The `generate_hash` function creates a SHA-256 hash from a given string input. It takes a single parameter, `data`, which is expected to be a string. The function encodes this string and computes its SHA-256 hash, returning the resulting hash as a hexadecimal string. Developers would use this function for securely storing passwords, verifying data integrity, or generating unique identifiers. It addresses security concerns by providing a robust hashing mechanism that helps prevent data tampering and enhances data protection."
    },
    {
      "type": "function",
      "name": "format_currency",
      "content": "def format_currency(amount: Decimal, currency: str = \"USD\") -> str:\n    \"\"\"Format currency amount\"\"\"\n    return f\"${amount:.2f} {currency}\"",
      "metadata": {
        "file_path": "app/utils/helpers.py",
        "chunk_type": "function",
        "name": "format_currency",
        "purpose": "Format currency amount",
        "dependencies": [],
        "access_level": "public",
        "function_name": "format_currency",
        "parameters": [
          "amount: Decimal",
          "currency: str"
        ],
        "return_type": "str",
        "decorators": [],
        "is_async": false
      },
      "description": "The `format_currency` function formats a given currency amount into a standardized string representation. It accepts two parameters: `amount`, which is a Decimal representing the monetary value, and `currency`, a string that defaults to \"USD\" if not provided. The function returns a string formatted as \"$amount currency\", ensuring the amount is displayed with two decimal places. Developers would use this function when they need to present monetary values in a user-friendly format, particularly in financial applications or reports. It solves the problem of inconsistent currency formatting by providing a clear and uniform output for various currency amounts."
    },
    {
      "type": "function",
      "name": "format_datetime",
      "content": "def format_datetime(dt: datetime, format_str: str = \"%Y-%m-%d %H:%M:%S\") -> str:\n    \"\"\"Format datetime object\"\"\"\n    return dt.strftime(format_str)",
      "metadata": {
        "file_path": "app/utils/helpers.py",
        "chunk_type": "function",
        "name": "format_datetime",
        "purpose": "Format datetime object",
        "dependencies": [],
        "access_level": "public",
        "function_name": "format_datetime",
        "parameters": [
          "dt: datetime",
          "format_str: str"
        ],
        "return_type": "str",
        "decorators": [],
        "is_async": false
      },
      "description": "The `format_datetime` function in Python formats a given `datetime` object into a specified string format. It accepts two parameters: `dt`, which is a `datetime` object, and `format_str`, a string that defines the desired output format (defaulting to \"%Y-%m-%d %H:%M:%S\"). The function returns the formatted date and time as a string. Developers would use this function when they need to present date and time in a specific format, such as for logging, user interfaces, or data export. It solves the problem of converting complex `datetime` objects into human-readable string representations, ensuring consistency in date formatting across applications."
    },
    {
      "type": "function",
      "name": "parse_datetime",
      "content": "def parse_datetime(date_string: str, format_str: str = \"%Y-%m-%d %H:%M:%S\") -> Optional[datetime]:\n    \"\"\"Parse datetime string\"\"\"\n    try:\n        return datetime.strptime(date_string, format_str)\n    except ValueError:\n        return None",
      "metadata": {
        "file_path": "app/utils/helpers.py",
        "chunk_type": "function",
        "name": "parse_datetime",
        "purpose": "Parse datetime string",
        "dependencies": [],
        "access_level": "public",
        "function_name": "parse_datetime",
        "parameters": [
          "date_string: str",
          "format_str: str"
        ],
        "return_type": "Optional[datetime]",
        "decorators": [],
        "is_async": false
      },
      "description": "The `parse_datetime` function is designed to convert a datetime string into a `datetime` object based on a specified format. It accepts two parameters: `date_string`, which is the string representation of the date and time, and `format_str`, which defines the expected format of the `date_string` (defaulting to \"%Y-%m-%d %H:%M:%S\"). The function attempts to parse the input string and returns a `datetime` object if successful; otherwise, it returns `None` in the event of a `ValueError`. Developers can use this function when they need to validate and convert date strings into `datetime` objects for further manipulation or analysis, effectively solving issues related to date format inconsistencies and parsing errors."
    },
    {
      "type": "function",
      "name": "calculate_tax",
      "content": "def calculate_tax(amount: Decimal, tax_rate: float = 0.08) -> Decimal:\n    \"\"\"Calculate tax amount\"\"\"\n    return amount * Decimal(str(tax_rate))",
      "metadata": {
        "file_path": "app/utils/helpers.py",
        "chunk_type": "function",
        "name": "calculate_tax",
        "purpose": "Calculate tax amount",
        "dependencies": [],
        "access_level": "public",
        "function_name": "calculate_tax",
        "parameters": [
          "amount: Decimal",
          "tax_rate: float"
        ],
        "return_type": "Decimal",
        "decorators": [],
        "is_async": false
      },
      "description": "The `calculate_tax` function computes the tax amount based on a specified monetary amount and tax rate. It accepts two parameters: `amount`, which is a Decimal representing the monetary value to be taxed, and `tax_rate`, a float that defaults to 0.08 (8%). The function returns the calculated tax as a Decimal. Developers would use this function when they need to determine tax liabilities for financial calculations or invoicing. It effectively solves the problem of accurately calculating tax amounts while ensuring precision with Decimal types, which is crucial for financial applications to avoid floating-point errors."
    },
    {
      "type": "function",
      "name": "calculate_shipping",
      "content": "def calculate_shipping(weight: Decimal, base_rate: Decimal = Decimal('5.00')) -> Decimal:\n    \"\"\"Calculate shipping cost based on weight\"\"\"\n    if weight <= Decimal('1.0'):\n        return base_rate\n    elif weight <= Decimal('5.0'):\n        return base_rate + Decimal('2.00')\n    else:\n        return base_rate + Decimal('5.00')",
      "metadata": {
        "file_path": "app/utils/helpers.py",
        "chunk_type": "function",
        "name": "calculate_shipping",
        "purpose": "Calculate shipping cost based on weight",
        "dependencies": [],
        "access_level": "public",
        "function_name": "calculate_shipping",
        "parameters": [
          "weight: Decimal",
          "base_rate: Decimal"
        ],
        "return_type": "Decimal",
        "decorators": [],
        "is_async": false
      },
      "description": "**Function Description: `calculate_shipping`**\n\nThe `calculate_shipping` function computes the shipping cost based on the weight of a package. It accepts two parameters: `weight`, a Decimal representing the weight of the package, and `base_rate`, a Decimal with a default value of 5.00, which serves as the starting shipping cost. \n\nThe function returns a Decimal value representing the total shipping cost. The cost structure is as follows:\n- If the weight is 1.0 pounds or less, the shipping cost is equal to the base rate.\n- If the weight is between 1.0 and 5.0 pounds, an additional charge of 2.00 is added to the base rate.\n- For weights exceeding 5.0 pounds, an additional charge of 5.00 is applied.\n\nDevelopers would use this function in e-commerce applications or logistics systems where shipping costs need to be calculated dynamically based on package weight. It effectively solves the problem of determining variable shipping"
    },
    {
      "type": "function",
      "name": "paginate_results",
      "content": "def paginate_results(\n    items: List[Any],\n    page: int = 1,\n    page_size: int = 20\n) -> Dict[str, Any]:\n    \"\"\"Paginate a list of items\"\"\"\n    total = len(items)\n    start = (page - 1) * page_size\n    end = start + page_size\n    \n    paginated_items = items[start:end]\n    total_pages = (total + page_size - 1) // page_size\n    \n    return {\n        \"items\": paginated_items,\n        \"total\": total,\n        \"page\": page,\n        \"page_size\": page_size,\n        \"total_pages\": total_pages,\n        \"has_next\": page < total_pages,\n        \"has_prev\": page > 1\n    }",
      "metadata": {
        "file_path": "app/utils/helpers.py",
        "chunk_type": "function",
        "name": "paginate_results",
        "purpose": "Paginate a list of items",
        "dependencies": [],
        "access_level": "public",
        "function_name": "paginate_results",
        "parameters": [
          "items: List[Any]",
          "page: int",
          "page_size: int"
        ],
        "return_type": "Dict[str, Any]",
        "decorators": [],
        "is_async": false
      },
      "description": "The `paginate_results` function in Python is designed to paginate a list of items, facilitating the display of data in manageable chunks. It accepts three parameters: `items`, a list of any type; `page`, an integer indicating the current page number (default is 1); and `page_size`, an integer specifying the number of items per page (default is 20). \n\nThe function calculates the total number of items, determines the starting and ending indices for the current page, and slices the list accordingly to retrieve the relevant items. It returns a dictionary containing the paginated items, total item count, current page number, page size, total number of pages, and boolean flags indicating the presence of next and previous pages.\n\nDevelopers would use this function when implementing pagination in applications, such as web interfaces or APIs, to enhance user experience by preventing overwhelming data displays. It effectively solves the problem of managing large datasets by breaking them into smaller, navigable segments, improving both performance and usability."
    },
    {
      "type": "function",
      "name": "filter_dict",
      "content": "def filter_dict(data: Dict[str, Any], allowed_keys: List[str]) -> Dict[str, Any]:\n    \"\"\"Filter dictionary to only include allowed keys\"\"\"\n    return {key: value for key, value in data.items() if key in allowed_keys}",
      "metadata": {
        "file_path": "app/utils/helpers.py",
        "chunk_type": "function",
        "name": "filter_dict",
        "purpose": "Filter dictionary to only include allowed keys",
        "dependencies": [],
        "access_level": "public",
        "function_name": "filter_dict",
        "parameters": [
          "data: Dict[str, Any]",
          "allowed_keys: List[str]"
        ],
        "return_type": "Dict[str, Any]",
        "decorators": [],
        "is_async": false
      },
      "description": "The `filter_dict` function is designed to filter a given dictionary, returning a new dictionary that only includes specified allowed keys. It takes two parameters: `data`, which is a dictionary with string keys and values of any type, and `allowed_keys`, a list of strings representing the keys that should be retained in the output. The function returns a dictionary containing only the key-value pairs from the original dictionary where the keys are present in the `allowed_keys` list. \n\nDevelopers would use this function when they need to sanitize or restrict the contents of a dictionary, ensuring that only certain keys are included, which is particularly useful in scenarios like API data validation, configuration management, or when processing user input. This function effectively solves the problem of unwanted or extraneous data in dictionaries, enhancing data integrity and security."
    },
    {
      "type": "function",
      "name": "merge_dicts",
      "content": "def merge_dicts(*dicts: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Merge multiple dictionaries\"\"\"\n    result = {}\n    for d in dicts:\n        result.update(d)\n    return result",
      "metadata": {
        "file_path": "app/utils/helpers.py",
        "chunk_type": "function",
        "name": "merge_dicts",
        "purpose": "Merge multiple dictionaries",
        "dependencies": [],
        "access_level": "public",
        "function_name": "merge_dicts",
        "parameters": [],
        "return_type": "Dict[str, Any]",
        "decorators": [],
        "is_async": false
      },
      "description": "**Function Description: `merge_dicts`**\n\nThe `merge_dicts` function in Python is designed to merge multiple dictionaries into a single dictionary. It accepts a variable number of dictionary arguments, indicated by `*dicts`, where each dictionary can contain string keys and values of any type (`Dict[str, Any]`). The function iterates through each provided dictionary and updates a cumulative result dictionary with their key-value pairs. \n\n**Inputs:** \n- A variable number of dictionaries (`*dicts`), each formatted as `Dict[str, Any]`.\n\n**Returns:** \n- A single dictionary (`Dict[str, Any]`) that contains all unique key-value pairs from the input dictionaries. If there are duplicate keys, the values from the later dictionaries will overwrite those from earlier ones.\n\n**Use Cases:**\nDevelopers would use this function when they need to consolidate multiple dictionaries into one, such as when aggregating configuration settings, combining data from different sources, or simplifying data management in applications."
    },
    {
      "type": "function",
      "name": "deep_merge_dicts",
      "content": "def deep_merge_dicts(dict1: Dict[str, Any], dict2: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Deep merge two dictionaries\"\"\"\n    result = dict1.copy()\n    \n    for key, value in dict2.items():\n        if key in result and isinstance(result[key], dict) and isinstance(value, dict):\n            result[key] = deep_merge_dicts(result[key], value)\n        else:\n            result[key] = value\n    \n    return result",
      "metadata": {
        "file_path": "app/utils/helpers.py",
        "chunk_type": "function",
        "name": "deep_merge_dicts",
        "purpose": "Deep merge two dictionaries",
        "dependencies": [],
        "access_level": "public",
        "function_name": "deep_merge_dicts",
        "parameters": [
          "dict1: Dict[str, Any]",
          "dict2: Dict[str, Any]"
        ],
        "return_type": "Dict[str, Any]",
        "decorators": [],
        "is_async": false
      },
      "description": "**Function Description: deep_merge_dicts**\n\nThe `deep_merge_dicts` function in Python is designed to perform a deep merge of two dictionaries, allowing for the combination of nested structures. It takes two parameters: `dict1` and `dict2`, both of which are dictionaries with string keys and values of any type (`Dict[str, Any]`). \n\nThe function returns a new dictionary that contains all key-value pairs from `dict1`, with values from `dict2` merging into it. If a key exists in both dictionaries and the corresponding values are also dictionaries, it recursively merges these nested dictionaries. Otherwise, the value from `dict2` will overwrite the value from `dict1`.\n\nDevelopers would use this function when they need to combine configurations, settings, or data structures that may contain nested dictionaries, ensuring that no data is lost in the merging process. It effectively solves the problem of merging complex data structures while preserving the integrity of nested data."
    },
    {
      "type": "function",
      "name": "chunk_list",
      "content": "def chunk_list(items: List[Any], chunk_size: int) -> List[List[Any]]:\n    \"\"\"Split list into chunks of specified size\"\"\"\n    return [items[i:i + chunk_size] for i in range(0, len(items), chunk_size)]",
      "metadata": {
        "file_path": "app/utils/helpers.py",
        "chunk_type": "function",
        "name": "chunk_list",
        "purpose": "Split list into chunks of specified size",
        "dependencies": [],
        "access_level": "public",
        "function_name": "chunk_list",
        "parameters": [
          "items: List[Any]",
          "chunk_size: int"
        ],
        "return_type": "List[List[Any]]",
        "decorators": [],
        "is_async": false
      },
      "description": "The `chunk_list` function in Python is designed to divide a given list into smaller sublists (chunks) of a specified size. It takes two parameters: `items`, which is a list of any data type, and `chunk_size`, an integer that defines the maximum number of elements each chunk should contain. The function returns a list of lists, where each inner list represents a chunk of the original list. Developers often use this function when they need to process large datasets in manageable parts, such as when implementing pagination, batching operations, or improving performance in data processing tasks. By breaking down a large list into smaller chunks, it helps to optimize memory usage and enhance the efficiency of algorithms that operate on lists."
    },
    {
      "type": "function",
      "name": "remove_duplicates",
      "content": "def remove_duplicates(items: List[Any]) -> List[Any]:\n    \"\"\"Remove duplicates from list while preserving order\"\"\"\n    seen = set()\n    result = []\n    for item in items:\n        if item not in seen:\n            seen.add(item)\n            result.append(item)\n    return result",
      "metadata": {
        "file_path": "app/utils/helpers.py",
        "chunk_type": "function",
        "name": "remove_duplicates",
        "purpose": "Remove duplicates from list while preserving order",
        "dependencies": [],
        "access_level": "public",
        "function_name": "remove_duplicates",
        "parameters": [
          "items: List[Any]"
        ],
        "return_type": "List[Any]",
        "decorators": [],
        "is_async": false
      },
      "description": "The `remove_duplicates` function is designed to eliminate duplicate entries from a list while maintaining the original order of elements. It accepts a single parameter, `items`, which is a list of any data type (`List[Any]`). The function processes the input list and returns a new list that contains only unique elements, preserving their initial sequence. Developers would use this function when they need to ensure data integrity by removing redundancy in lists, such as when processing user inputs or cleaning datasets. This function effectively solves the problem of duplicate values, making it easier to work with distinct items in various applications."
    },
    {
      "type": "function",
      "name": "safe_divide",
      "content": "def safe_divide(numerator: Decimal, denominator: Decimal) -> Decimal:\n    \"\"\"Safely divide two decimals, returning 0 if denominator is 0\"\"\"\n    if denominator == 0:\n        return Decimal('0')\n    return numerator / denominator",
      "metadata": {
        "file_path": "app/utils/helpers.py",
        "chunk_type": "function",
        "name": "safe_divide",
        "purpose": "Safely divide two decimals, returning 0 if denominator is 0",
        "dependencies": [],
        "access_level": "public",
        "function_name": "safe_divide",
        "parameters": [
          "numerator: Decimal",
          "denominator: Decimal"
        ],
        "return_type": "Decimal",
        "decorators": [],
        "is_async": false
      },
      "description": "The `safe_divide` function in Python performs a safe division of two `Decimal` numbers. It takes two parameters: `numerator` and `denominator`, both of type `Decimal`. The function returns a `Decimal` result of the division. If the `denominator` is zero, it returns `0` instead of raising a division error. Developers would use this function when they need to ensure safe division operations in financial calculations or other contexts where precision is critical. It solves the problem of handling division by zero gracefully, preventing runtime exceptions and ensuring robust code execution."
    },
    {
      "type": "function",
      "name": "round_to_cents",
      "content": "def round_to_cents(amount: Decimal) -> Decimal:\n    \"\"\"Round amount to 2 decimal places (cents)\"\"\"\n    return amount.quantize(Decimal('0.01'))",
      "metadata": {
        "file_path": "app/utils/helpers.py",
        "chunk_type": "function",
        "name": "round_to_cents",
        "purpose": "Round amount to 2 decimal places (cents)",
        "dependencies": [],
        "access_level": "public",
        "function_name": "round_to_cents",
        "parameters": [
          "amount: Decimal"
        ],
        "return_type": "Decimal",
        "decorators": [],
        "is_async": false
      },
      "description": "**Function Description: `round_to_cents`**\n\nThe `round_to_cents` function is designed to round a given monetary amount to two decimal places, effectively representing cents. It accepts a single parameter, `amount`, which should be of type `Decimal`. The function utilizes the `quantize` method of the `Decimal` class to achieve precise rounding.\n\n**Input:** \n- `amount: Decimal` - A monetary value represented as a Decimal object.\n\n**Returns:** \n- `Decimal` - The input amount rounded to two decimal places.\n\n**Use Cases:** \nDevelopers would use this function in financial applications where accurate monetary calculations are essential, such as in billing systems, payment processing, or any scenario that requires rounding to the nearest cent.\n\n**Problem Solved:** \nThis function addresses the common issue of floating-point inaccuracies in monetary calculations by ensuring that amounts are rounded correctly to the nearest cent, thereby maintaining financial precision and compliance with currency formatting standards."
    },
    {
      "type": "function",
      "name": "is_valid_date_range",
      "content": "def is_valid_date_range(start_date: datetime, end_date: datetime) -> bool:\n    \"\"\"Check if date range is valid (start < end)\"\"\"\n    return start_date < end_date",
      "metadata": {
        "file_path": "app/utils/helpers.py",
        "chunk_type": "function",
        "name": "is_valid_date_range",
        "purpose": "Check if date range is valid (start < end)",
        "dependencies": [],
        "access_level": "public",
        "function_name": "is_valid_date_range",
        "parameters": [
          "start_date: datetime",
          "end_date: datetime"
        ],
        "return_type": "bool",
        "decorators": [],
        "is_async": false
      },
      "description": "The `is_valid_date_range` function in Python verifies the validity of a date range by checking if the `start_date` is earlier than the `end_date`. It accepts two parameters: `start_date` and `end_date`, both of which should be of the `datetime` type. The function returns a boolean value`True` if the date range is valid and `False` otherwise. Developers would use this function when validating user input for date ranges, ensuring that the start date precedes the end date. This function helps prevent logical errors in applications that rely on accurate date range inputs, such as scheduling systems or event planners."
    },
    {
      "type": "function",
      "name": "get_date_range_days",
      "content": "def get_date_range_days(start_date: datetime, end_date: datetime) -> int:\n    \"\"\"Get number of days between two dates\"\"\"\n    return (end_date - start_date).days",
      "metadata": {
        "file_path": "app/utils/helpers.py",
        "chunk_type": "function",
        "name": "get_date_range_days",
        "purpose": "Get number of days between two dates",
        "dependencies": [],
        "access_level": "public",
        "function_name": "get_date_range_days",
        "parameters": [
          "start_date: datetime",
          "end_date: datetime"
        ],
        "return_type": "int",
        "decorators": [],
        "is_async": false
      },
      "description": "The `get_date_range_days` function calculates the number of days between two specified dates. It takes two parameters: `start_date` and `end_date`, both of which should be of the `datetime` type. The function returns an integer representing the total number of days between the two dates. Developers would use this function when they need to determine the duration of time in days for scheduling, event planning, or data analysis. It effectively solves the problem of manually calculating date differences, providing a straightforward and efficient way to obtain this information."
    },
    {
      "type": "function",
      "name": "truncate_string",
      "content": "def truncate_string(text: str, max_length: int, suffix: str = \"...\") -> str:\n    \"\"\"Truncate string to maximum length\"\"\"\n    if len(text) <= max_length:\n        return text\n    return text[:max_length - len(suffix)] + suffix",
      "metadata": {
        "file_path": "app/utils/helpers.py",
        "chunk_type": "function",
        "name": "truncate_string",
        "purpose": "Truncate string to maximum length",
        "dependencies": [],
        "access_level": "public",
        "function_name": "truncate_string",
        "parameters": [
          "text: str",
          "max_length: int",
          "suffix: str"
        ],
        "return_type": "str",
        "decorators": [],
        "is_async": false
      },
      "description": "**Function Description: `truncate_string`**\n\nThe `truncate_string` function is designed to shorten a given string to a specified maximum length while appending a suffix to indicate truncation. It accepts three parameters: `text` (the string to be truncated), `max_length` (the maximum allowable length of the output string), and an optional `suffix` (defaulting to \"...\") that is appended if truncation occurs. \n\nThe function returns the original string if its length is less than or equal to `max_length`. If truncation is necessary, it returns a substring of `text` that fits within the specified length, minus the length of the suffix, ensuring the suffix is included in the final output.\n\nDevelopers would use this function when they need to display text in a constrained space, such as in user interfaces or logs, where maintaining readability while adhering to length limits is essential. It effectively solves the problem of overly long strings that could disrupt layout or readability, providing a clear indication"
    },
    {
      "type": "imports",
      "name": "module_imports",
      "content": "Module Dependencies:\n\nThird Party: sqlalchemy\n  - Column, Integer, String, Boolean, DateTime, Text\n\nThird Party: sqlalchemy.sql\n  - func\n\nThird Party: sqlalchemy.orm\n  - relationship\n\nLocal: app.core.database\n  - Base",
      "metadata": {
        "file_path": "app/models/user.py",
        "chunk_type": "imports",
        "name": "module_imports",
        "purpose": "Module dependencies and imports",
        "dependencies": [],
        "access_level": "public",
        "imports": [
          {
            "module": "sqlalchemy",
            "type": "third_party",
            "items": [
              "Column",
              "Integer",
              "String",
              "Boolean",
              "DateTime",
              "Text"
            ]
          },
          {
            "module": "sqlalchemy.sql",
            "type": "third_party",
            "items": [
              "func"
            ]
          },
          {
            "module": "sqlalchemy.orm",
            "type": "third_party",
            "items": [
              "relationship"
            ]
          },
          {
            "module": "app.core.database",
            "type": "local",
            "items": [
              "Base"
            ]
          }
        ]
      },
      "description": "The `module_imports` Python module manages dependencies and imports essential for database interactions within the application. It relies on the third-party library `sqlalchemy`, which provides key components such as `Column`, `Integer`, `String`, `Boolean`, `DateTime`, and `Text` for defining database schemas. Additionally, it utilizes `sqlalchemy.sql.func` for executing SQL functions and `sqlalchemy.orm.relationship` for establishing relationships between database models.\n\nThis module also imports the local `Base` class from `app.core.database`, which serves as the declarative base for ORM models. By integrating these dependencies, the module facilitates the creation and management of database entities, ensuring seamless data handling within the system. Overall, it plays a critical role in enabling structured data operations while leveraging the robust capabilities of SQLAlchemy."
    },
    {
      "type": "class",
      "name": "User",
      "content": "class User:\n    # Inherits from: Base\n    # Purpose: User model\n\n    def __repr__(self, ...):\n        # Method implementation\n\n    def full_name(self, ...):\n        # Method implementation\n\n    def to_dict(self, ...):\n        # Method implementation",
      "metadata": {
        "file_path": "app/models/user.py",
        "chunk_type": "class",
        "name": "User",
        "purpose": "User model",
        "dependencies": [],
        "access_level": "public",
        "class_name": "User",
        "methods": [
          "__repr__",
          "full_name",
          "to_dict"
        ],
        "attributes": [],
        "base_classes": [
          "Base"
        ],
        "decorators": []
      },
      "description": "**Description of the User Class in Python**\n\nThe `User` class represents a user model within a software application, serving as a blueprint for user-related data and behavior. It inherits from a base class, likely providing foundational attributes and methods common to all models in the system. \n\nThis class addresses the need for structured user data management, encapsulating user attributes and functionalities. It includes three key methods: `__repr__`, which provides a string representation of the user object; `full_name`, which likely concatenates first and last names to return the user's complete name; and `to_dict`, which converts the user object into a dictionary format for easier data manipulation and serialization.\n\nDevelopers would use the `User` class when building applications that require user authentication, profile management, or any feature that involves user data handling. It fits into the system by providing a standardized way to interact with user information, ensuring consistency and ease of use across various components of the application."
    },
    {
      "type": "function",
      "name": "__repr__",
      "content": "    def __repr__(self):\n        return f\"<User(id={self.id}, email='{self.email}', username='{self.username}')>\"",
      "metadata": {
        "file_path": "app/models/user.py",
        "chunk_type": "function",
        "name": "__repr__",
        "purpose": "Function __repr__",
        "dependencies": [],
        "access_level": "public",
        "function_name": "__repr__",
        "parameters": [
          "self"
        ],
        "return_type": "",
        "decorators": [],
        "is_async": false
      },
      "description": "The `__repr__` function in Python is a special method that provides a string representation of an instance of a class, specifically designed for debugging and logging purposes. This function expects a single input parameter, `self`, which refers to the instance of the class it is defined in. It returns a formatted string that includes the user's `id`, `email`, and `username`, structured as `<User(id=..., email='...', username='...')>`. \n\nDevelopers use this function to obtain a clear and informative representation of user objects, making it easier to inspect and understand the state of an object during development or debugging. By providing a concise summary of key attributes, it helps in quickly identifying issues or verifying object properties, thus enhancing the overall efficiency of code maintenance and troubleshooting."
    },
    {
      "type": "function",
      "name": "full_name",
      "content": "    def full_name(self) -> str:\n        \"\"\"Get user's full name\"\"\"\n        if self.first_name and self.last_name:\n            return f\"{self.first_name} {self.last_name}\"\n        return self.username",
      "metadata": {
        "file_path": "app/models/user.py",
        "chunk_type": "function",
        "name": "full_name",
        "purpose": "Get user's full name",
        "dependencies": [],
        "access_level": "public",
        "function_name": "full_name",
        "parameters": [
          "self"
        ],
        "return_type": "str",
        "decorators": [
          "property"
        ],
        "is_async": false
      },
      "description": "The `full_name` function is a method designed to retrieve a user's full name by concatenating their first and last names. It expects a single parameter, `self`, which refers to the instance of the class containing user attributes. The function returns a string: if both `first_name` and `last_name` attributes are present, it returns them formatted as \"First Last\"; otherwise, it defaults to returning the `username` attribute. Developers would use this function in user profile management scenarios where displaying a user's full name is necessary. It solves the problem of ensuring that a user's identity is presented clearly, accommodating cases where full names may not be available."
    },
    {
      "type": "function",
      "name": "to_dict",
      "content": "    def to_dict(self) -> dict:\n        \"\"\"Convert user to dictionary\"\"\"\n        return {\n            \"id\": self.id,\n            \"email\": self.email,\n            \"username\": self.username,\n            \"first_name\": self.first_name,\n            \"last_name\": self.last_name,\n            \"is_active\": self.is_active,\n            \"is_admin\": self.is_admin,\n            \"phone\": self.phone,\n            \"address\": self.address,\n            \"created_at\": self.created_at.isoformat() if self.created_at else None,\n            \"updated_at\": self.updated_at.isoformat() if self.updated_at else None\n        }",
      "metadata": {
        "file_path": "app/models/user.py",
        "chunk_type": "function",
        "name": "to_dict",
        "purpose": "Convert user to dictionary",
        "dependencies": [],
        "access_level": "public",
        "function_name": "to_dict",
        "parameters": [
          "self"
        ],
        "return_type": "dict",
        "decorators": [],
        "is_async": false
      },
      "description": "**Function Description: `to_dict`**\n\nThe `to_dict` function is a method designed to convert a user object into a dictionary format. It expects a single parameter, `self`, which refers to the instance of the user class. The function returns a dictionary containing key attributes of the user, including `id`, `email`, `username`, `first_name`, `last_name`, `is_active`, `is_admin`, `phone`, `address`, and timestamps for `created_at` and `updated_at` (formatted as ISO strings if they exist).\n\nDevelopers would use this function when they need to serialize user data for APIs, data storage, or logging purposes. It simplifies the process of transforming complex user objects into a more manageable and interoperable format, addressing the need for data representation in applications that require JSON or dictionary-like structures."
    },
    {
      "type": "imports",
      "name": "module_imports",
      "content": "Module Dependencies:\n\nThird Party: sqlalchemy\n  - Column, Integer, String, Text, Numeric, DateTime, ForeignKey, Enum\n\nThird Party: sqlalchemy.sql\n  - func\n\nThird Party: sqlalchemy.orm\n  - relationship\n\nThird Party: enum\n  - enum\n\nLocal: app.core.database\n  - Base",
      "metadata": {
        "file_path": "app/models/order.py",
        "chunk_type": "imports",
        "name": "module_imports",
        "purpose": "Module dependencies and imports",
        "dependencies": [],
        "access_level": "public",
        "imports": [
          {
            "module": "sqlalchemy",
            "type": "third_party",
            "items": [
              "Column",
              "Integer",
              "String",
              "Text",
              "Numeric",
              "DateTime",
              "ForeignKey",
              "Enum"
            ]
          },
          {
            "module": "sqlalchemy.sql",
            "type": "third_party",
            "items": [
              "func"
            ]
          },
          {
            "module": "sqlalchemy.orm",
            "type": "third_party",
            "items": [
              "relationship"
            ]
          },
          {
            "module": "enum",
            "type": "third_party",
            "items": [
              "enum"
            ]
          },
          {
            "module": "app.core.database",
            "type": "local",
            "items": [
              "Base"
            ]
          }
        ]
      },
      "description": "The `module_imports` Python module manages dependencies essential for database operations within an application. It relies on several third-party libraries, primarily SQLAlchemy, which provides robust ORM capabilities for database interaction. Key imports from SQLAlchemy include `Column`, `Integer`, `String`, `Text`, `Numeric`, `DateTime`, `ForeignKey`, and `Enum` for defining database schemas, as well as `func` from `sqlalchemy.sql` for executing SQL functions and `relationship` from `sqlalchemy.orm` for establishing relationships between database entities. Additionally, it utilizes the built-in `enum` module for defining enumerated types. The module also imports `Base` from the local `app.core.database`, which serves as the declarative base class for SQLAlchemy models. Overall, this module is integral to the application's data management layer, facilitating structured data storage and retrieval through its comprehensive set of dependencies."
    },
    {
      "type": "constants",
      "name": "module_constants",
      "content": "Module Constants:\n\nPENDING = 'pending'\nCONFIRMED = 'confirmed'\nPROCESSING = 'processing'\nSHIPPED = 'shipped'\nDELIVERED = 'delivered'\nCANCELLED = 'cancelled'\nREFUNDED = 'refunded'",
      "metadata": {
        "file_path": "app/models/order.py",
        "chunk_type": "constants",
        "name": "module_constants",
        "purpose": "Module-level constants and configuration",
        "dependencies": [],
        "access_level": "public",
        "constant_name": "",
        "constant_type": "",
        "usage": "",
        "constants": [
          {
            "name": "PENDING",
            "value": "'pending'"
          },
          {
            "name": "CONFIRMED",
            "value": "'confirmed'"
          },
          {
            "name": "PROCESSING",
            "value": "'processing'"
          },
          {
            "name": "SHIPPED",
            "value": "'shipped'"
          },
          {
            "name": "DELIVERED",
            "value": "'delivered'"
          },
          {
            "name": "CANCELLED",
            "value": "'cancelled'"
          },
          {
            "name": "REFUNDED",
            "value": "'refunded'"
          }
        ]
      },
      "description": "This code defines a set of module-level constants for managing order statuses in a system. The constants include: PENDING, CONFIRMED, PROCESSING, SHIPPED, DELIVERED, CANCELLED, and REFUNDED. These predefined strings represent various stages in an order lifecycle, facilitating consistent status tracking and management throughout the application. This code is typically used in e-commerce or order management systems to ensure clarity and uniformity in handling order states."
    },
    {
      "type": "class",
      "name": "OrderStatus",
      "content": "class OrderStatus:\n    # Inherits from: enum.Enum\n    # Purpose: Order status enumeration",
      "metadata": {
        "file_path": "app/models/order.py",
        "chunk_type": "class",
        "name": "OrderStatus",
        "purpose": "Order status enumeration",
        "dependencies": [],
        "access_level": "public",
        "class_name": "OrderStatus",
        "methods": [],
        "attributes": [],
        "base_classes": [
          "enum.Enum"
        ],
        "decorators": []
      },
      "description": "**Description of the OrderStatus Class:**\n\nThe `OrderStatus` class is an enumeration that represents various states of an order within an e-commerce or order management system. By inheriting from `enum.Enum`, it provides a structured way to define and manage order statuses, such as 'Pending', 'Shipped', 'Delivered', and 'Cancelled'. \n\nThis class solves the problem of hardcoding status values throughout the codebase, promoting consistency and reducing errors. Developers would use it when implementing order processing logic, ensuring that only valid statuses are assigned and checked, which enhances code readability and maintainability.\n\nIn the broader system, the `OrderStatus` class integrates with order handling modules, facilitating status checks and transitions, thereby streamlining order lifecycle management. Its clear enumeration of statuses aids in debugging and enhances communication among team members regarding order states."
    },
    {
      "type": "class",
      "name": "Order",
      "content": "class Order:\n    # Inherits from: Base\n    # Purpose: Order model\n\n    def __repr__(self, ...):\n        # Method implementation\n\n    def item_count(self, ...):\n        # Method implementation\n\n    def to_dict(self, ...):\n        # Method implementation",
      "metadata": {
        "file_path": "app/models/order.py",
        "chunk_type": "class",
        "name": "Order",
        "purpose": "Order model",
        "dependencies": [],
        "access_level": "public",
        "class_name": "Order",
        "methods": [
          "__repr__",
          "item_count",
          "to_dict"
        ],
        "attributes": [],
        "base_classes": [
          "Base"
        ],
        "decorators": []
      },
      "description": "**Description of the Order Class in Python**\n\nThe `Order` class serves as a model for representing customer orders within an application. It inherits from a base class, providing foundational attributes and methods that enhance its functionality. This class addresses the need for structured order management by encapsulating order-related data and behaviors.\n\nKey features include:\n- **`__repr__` Method**: Provides a string representation of the order object, facilitating easier debugging and logging.\n- **`item_count` Method**: Calculates and returns the total number of items in the order, aiding in inventory management and order processing.\n- **`to_dict` Method**: Converts the order object into a dictionary format, simplifying data serialization and integration with APIs or databases.\n\nDevelopers would use this class when building e-commerce platforms, inventory systems, or any application requiring order tracking and management. Its design allows for seamless integration into larger systems, ensuring that order data is consistently handled and easily accessible."
    },
    {
      "type": "class",
      "name": "OrderItem",
      "content": "class OrderItem:\n    # Inherits from: Base\n    # Purpose: Order item model\n\n    def __repr__(self, ...):\n        # Method implementation\n\n    def to_dict(self, ...):\n        # Method implementation",
      "metadata": {
        "file_path": "app/models/order.py",
        "chunk_type": "class",
        "name": "OrderItem",
        "purpose": "Order item model",
        "dependencies": [],
        "access_level": "public",
        "class_name": "OrderItem",
        "methods": [
          "__repr__",
          "to_dict"
        ],
        "attributes": [],
        "base_classes": [
          "Base"
        ],
        "decorators": []
      },
      "description": "**Description of the OrderItem Class**\n\nThe `OrderItem` class serves as a model representing individual items within an order in an e-commerce or inventory management system. It inherits from a base class, `Base`, which likely provides foundational attributes and methods common to all models in the system.\n\nThis class addresses the need for structured data representation of order items, encapsulating properties such as item details, quantities, and pricing. Developers would utilize the `OrderItem` class when implementing features related to order processing, inventory tracking, or reporting, ensuring that each item in an order is accurately represented and easily manageable.\n\nThe class includes two key methods: `__repr__`, which provides a string representation of the order item for debugging and logging purposes, and `to_dict`, which converts the order item instance into a dictionary format, facilitating data serialization and integration with APIs or databases. Overall, the `OrderItem` class is integral to maintaining the integrity and functionality of order management systems."
    },
    {
      "type": "function",
      "name": "__repr__",
      "content": "    def __repr__(self):\n        return f\"<Order(id={self.id}, order_number='{self.order_number}', status='{self.status.value}')>\"",
      "metadata": {
        "file_path": "app/models/order.py",
        "chunk_type": "function",
        "name": "__repr__",
        "purpose": "Function __repr__",
        "dependencies": [],
        "access_level": "public",
        "function_name": "__repr__",
        "parameters": [
          "self"
        ],
        "return_type": "",
        "decorators": [],
        "is_async": false
      },
      "description": "The `__repr__` function in Python is a special method that provides a string representation of an instance of a class, specifically designed for debugging and logging purposes. This function expects a single parameter, `self`, which refers to the instance of the class. It returns a formatted string that includes the instance's `id`, `order_number`, and `status`, making it easier for developers to inspect the object's state.\n\nDevelopers would use this function when they need a clear and informative output of an object's attributes, particularly during development or debugging sessions. It solves the problem of understanding the current state of an object without needing to manually access each attribute, thereby enhancing code readability and maintainability."
    },
    {
      "type": "function",
      "name": "item_count",
      "content": "    def item_count(self) -> int:\n        \"\"\"Get total number of items in order\"\"\"\n        return sum(item.quantity for item in self.items)",
      "metadata": {
        "file_path": "app/models/order.py",
        "chunk_type": "function",
        "name": "item_count",
        "purpose": "Get total number of items in order",
        "dependencies": [],
        "access_level": "public",
        "function_name": "item_count",
        "parameters": [
          "self"
        ],
        "return_type": "int",
        "decorators": [
          "property"
        ],
        "is_async": false
      },
      "description": "**Function Description: `item_count`**\n\nThe `item_count` function calculates the total number of items in an order by summing the quantities of each item within the order. It is a method of a class, indicated by the `self` parameter, which represents the instance of the class containing a list of items. The function returns an integer value representing the total item count.\n\n**Inputs:** \n- `self`: An instance of the class that contains an attribute `items`, which is expected to be a collection of item objects, each having a `quantity` attribute.\n\n**Returns:** \n- An integer representing the total quantity of items in the order.\n\n**Use Cases:** \nDevelopers would use this function when they need to quickly determine the total number of items in an order, such as during checkout processes, inventory management, or reporting.\n\n**Problem Solved:** \nThe function simplifies the process of aggregating item quantities, allowing for efficient calculations of total items without manual iteration, thus"
    },
    {
      "type": "function",
      "name": "to_dict",
      "content": "    def to_dict(self) -> dict:\n        \"\"\"Convert order to dictionary\"\"\"\n        return {\n            \"id\": self.id,\n            \"user_id\": self.user_id,\n            \"order_number\": self.order_number,\n            \"status\": self.status.value,\n            \"subtotal\": float(self.subtotal) if self.subtotal else None,\n            \"tax_amount\": float(self.tax_amount) if self.tax_amount else None,\n            \"shipping_amount\": float(self.shipping_amount) if self.shipping_amount else None,\n            \"total_amount\": float(self.total_amount) if self.total_amount else None,\n            \"shipping_address\": self.shipping_address,\n            \"billing_address\": self.billing_address,\n            \"notes\": self.notes,\n            \"item_count\": self.item_count,\n            \"created_at\": self.created_at.isoformat() if self.created_at else None,\n            \"updated_at\": self.updated_at.isoformat() if self.updated_at else None\n        }",
      "metadata": {
        "file_path": "app/models/order.py",
        "chunk_type": "function",
        "name": "to_dict",
        "purpose": "Convert order to dictionary",
        "dependencies": [],
        "access_level": "public",
        "function_name": "to_dict",
        "parameters": [
          "self"
        ],
        "return_type": "dict",
        "decorators": [],
        "is_async": false
      },
      "description": "**Function Description: `to_dict`**\n\nThe `to_dict` function is a method designed to convert an order object into a dictionary format. It takes a single parameter, `self`, which refers to the instance of the order object. The function returns a dictionary containing key attributes of the order, including `id`, `user_id`, `order_number`, `status`, `subtotal`, `tax_amount`, `shipping_amount`, `total_amount`, `shipping_address`, `billing_address`, `notes`, `item_count`, and `created_at`. \n\nDevelopers would use this function when they need to serialize order data for storage, transmission, or integration with other systems, such as APIs or databases. It solves the problem of transforming complex order objects into a simple, structured format that is easy to manipulate and understand, facilitating data interchange and improving code readability."
    },
    {
      "type": "function",
      "name": "__repr__",
      "content": "    def __repr__(self):\n        return f\"<OrderItem(id={self.id}, order_id={self.order_id}, product_id={self.product_id}, quantity={self.quantity})>\"",
      "metadata": {
        "file_path": "app/models/order.py",
        "chunk_type": "function",
        "name": "__repr__",
        "purpose": "Function __repr__",
        "dependencies": [],
        "access_level": "public",
        "function_name": "__repr__",
        "parameters": [
          "self"
        ],
        "return_type": "",
        "decorators": [],
        "is_async": false
      },
      "description": "The `__repr__` function in Python is a special method that provides a string representation of an instance of a class, specifically for the `OrderItem` class. It takes a single parameter, `self`, which refers to the instance of the class. This function returns a formatted string that includes the `id`, `order_id`, `product_id`, and `quantity` attributes of the `OrderItem` instance, encapsulated within angle brackets for clarity.\n\nDevelopers use this function primarily for debugging and logging purposes, as it allows for a quick and informative overview of an object's state. By providing a clear representation of the object's key attributes, it helps in understanding the data contained within an instance at a glance. This function solves the problem of needing a human-readable format for complex objects, making it easier to track and manage instances during development and testing."
    },
    {
      "type": "function",
      "name": "to_dict",
      "content": "    def to_dict(self) -> dict:\n        \"\"\"Convert order item to dictionary\"\"\"\n        return {\n            \"id\": self.id,\n            \"order_id\": self.order_id,\n            \"product_id\": self.product_id,\n            \"quantity\": self.quantity,\n            \"unit_price\": float(self.unit_price) if self.unit_price else None,\n            \"total_price\": float(self.total_price) if self.total_price else None,\n            \"created_at\": self.created_at.isoformat() if self.created_at else None\n        }",
      "metadata": {
        "file_path": "app/models/order.py",
        "chunk_type": "function",
        "name": "to_dict",
        "purpose": "Convert order item to dictionary",
        "dependencies": [],
        "access_level": "public",
        "function_name": "to_dict",
        "parameters": [
          "self"
        ],
        "return_type": "dict",
        "decorators": [],
        "is_async": false
      },
      "description": "The `to_dict` function is a method designed to convert an order item object into a dictionary format. It expects a single parameter, `self`, which refers to the instance of the order item class. The function returns a dictionary containing key attributes of the order item, including `id`, `order_id`, `product_id`, `quantity`, `unit_price`, `total_price`, and `created_at`. Each attribute is formatted appropriately, with numeric values converted to floats and date values converted to ISO format when applicable.\n\nDevelopers would use this function when they need to serialize order item data for storage, transmission, or integration with other systems, such as APIs or databases. It addresses the problem of converting complex object structures into a simple, easily manageable format, facilitating data handling and interoperability in applications."
    },
    {
      "type": "imports",
      "name": "module_imports",
      "content": "Module Dependencies:\n\nLocal: app.models.user\n  - User\n\nLocal: app.models.product\n  - Product, ProductImage\n\nLocal: app.models.order\n  - Order, OrderItem\n\nLocal: app.models.category\n  - Category",
      "metadata": {
        "file_path": "app/models/__init__.py",
        "chunk_type": "imports",
        "name": "module_imports",
        "purpose": "Module dependencies and imports",
        "dependencies": [],
        "access_level": "public",
        "imports": [
          {
            "module": "app.models.user",
            "type": "local",
            "items": [
              "User"
            ]
          },
          {
            "module": "app.models.product",
            "type": "local",
            "items": [
              "Product",
              "ProductImage"
            ]
          },
          {
            "module": "app.models.order",
            "type": "local",
            "items": [
              "Order",
              "OrderItem"
            ]
          },
          {
            "module": "app.models.category",
            "type": "local",
            "items": [
              "Category"
            ]
          }
        ]
      },
      "description": "The `module_imports` module manages dependencies and imports for an application, specifically focusing on models related to user, product, order, and category functionalities. It imports the `User` class from `app.models.user`, `Product` and `ProductImage` classes from `app.models.product`, `Order` and `OrderItem` classes from `app.models.order`, and the `Category` class from `app.models.category`. This module serves as a central point for accessing core data models, facilitating the organization and interaction of user accounts, product listings, order processing, and category management within the system. It does not explicitly mention any external libraries, indicating that it primarily relies on local application modules."
    },
    {
      "type": "imports",
      "name": "module_imports",
      "content": "Module Dependencies:\n\nThird Party: sqlalchemy\n  - Column, Integer, String, Text, Numeric, Boolean, DateTime, ForeignKey\n\nThird Party: sqlalchemy.sql\n  - func\n\nThird Party: sqlalchemy.orm\n  - relationship\n\nLocal: app.core.database\n  - Base",
      "metadata": {
        "file_path": "app/models/product.py",
        "chunk_type": "imports",
        "name": "module_imports",
        "purpose": "Module dependencies and imports",
        "dependencies": [],
        "access_level": "public",
        "imports": [
          {
            "module": "sqlalchemy",
            "type": "third_party",
            "items": [
              "Column",
              "Integer",
              "String",
              "Text",
              "Numeric",
              "Boolean",
              "DateTime",
              "ForeignKey"
            ]
          },
          {
            "module": "sqlalchemy.sql",
            "type": "third_party",
            "items": [
              "func"
            ]
          },
          {
            "module": "sqlalchemy.orm",
            "type": "third_party",
            "items": [
              "relationship"
            ]
          },
          {
            "module": "app.core.database",
            "type": "local",
            "items": [
              "Base"
            ]
          }
        ]
      },
      "description": "The `module_imports` module manages dependencies and imports essential for database interactions within the application. It relies on the third-party library `sqlalchemy`, which provides a robust ORM framework for SQL database management. Key components imported include `Column`, `Integer`, `String`, `Text`, `Numeric`, `Boolean`, `DateTime`, and `ForeignKey` for defining database schemas, as well as `func` from `sqlalchemy.sql` for executing SQL functions. The `relationship` function from `sqlalchemy.orm` facilitates the establishment of relationships between database tables.\n\nAdditionally, the module imports `Base` from the local `app.core.database`, which serves as the declarative base class for model definitions. This module is integral to the system as it encapsulates the necessary components for defining and managing database entities, ensuring seamless integration with SQLAlchemy's ORM capabilities."
    },
    {
      "type": "class",
      "name": "Product",
      "content": "class Product:\n    # Inherits from: Base\n    # Purpose: Product model\n\n    def __repr__(self, ...):\n        # Method implementation\n\n    def is_in_stock(self, ...):\n        # Method implementation\n\n    def to_dict(self, ...):\n        # Method implementation",
      "metadata": {
        "file_path": "app/models/product.py",
        "chunk_type": "class",
        "name": "Product",
        "purpose": "Product model",
        "dependencies": [],
        "access_level": "public",
        "class_name": "Product",
        "methods": [
          "__repr__",
          "is_in_stock",
          "to_dict"
        ],
        "attributes": [],
        "base_classes": [
          "Base"
        ],
        "decorators": []
      },
      "description": "**Description of the Product Class**\n\nThe `Product` class serves as a model representing a product within an application, inheriting from a base class called `Base`. It encapsulates essential functionalities related to product management, including:\n\n1. **Representation**: The `__repr__` method provides a string representation of the product instance, facilitating easier debugging and logging.\n   \n2. **Stock Management**: The `is_in_stock` method checks the availability of the product, helping developers manage inventory and inform users about product availability.\n\n3. **Data Serialization**: The `to_dict` method converts the product instance into a dictionary format, which is useful for data interchange, API responses, or storage.\n\nDevelopers would utilize this class when building e-commerce platforms, inventory systems, or any application that requires product tracking and management. The `Product` class fits into the broader system by acting as a fundamental building block for product-related operations, ensuring a structured approach to handling product data and behavior."
    },
    {
      "type": "class",
      "name": "ProductImage",
      "content": "class ProductImage:\n    # Inherits from: Base\n    # Purpose: Product image model\n\n    def __repr__(self, ...):\n        # Method implementation\n\n    def to_dict(self, ...):\n        # Method implementation",
      "metadata": {
        "file_path": "app/models/product.py",
        "chunk_type": "class",
        "name": "ProductImage",
        "purpose": "Product image model",
        "dependencies": [],
        "access_level": "public",
        "class_name": "ProductImage",
        "methods": [
          "__repr__",
          "to_dict"
        ],
        "attributes": [],
        "base_classes": [
          "Base"
        ],
        "decorators": []
      },
      "description": "**Description of the ProductImage Class**\n\nThe `ProductImage` class represents a model for handling product images within an application, typically in e-commerce or inventory management systems. It inherits from a base class, `Base`, which likely provides foundational functionality such as data persistence or validation.\n\nThis class addresses the need for structured representation and manipulation of product images, enabling developers to easily manage image data associated with products. It includes two key methods: `__repr__`, which provides a string representation of the object for debugging and logging purposes, and `to_dict`, which converts the instance into a dictionary format, facilitating data serialization and integration with APIs or databases.\n\nDevelopers would use the `ProductImage` class when they need to manage product visuals, ensuring that images are consistently represented and easily accessible throughout the application. This class fits into the broader system by serving as a crucial component in the product management workflow, enhancing the user experience through effective image handling."
    },
    {
      "type": "function",
      "name": "__repr__",
      "content": "    def __repr__(self):\n        return f\"<Product(id={self.id}, name='{self.name}', sku='{self.sku}')>\"",
      "metadata": {
        "file_path": "app/models/product.py",
        "chunk_type": "function",
        "name": "__repr__",
        "purpose": "Function __repr__",
        "dependencies": [],
        "access_level": "public",
        "function_name": "__repr__",
        "parameters": [
          "self"
        ],
        "return_type": "",
        "decorators": [],
        "is_async": false
      },
      "description": "The `__repr__` function is a special method in Python that provides a string representation of an instance of a class, specifically designed for debugging and logging. This function expects a single input parameter, `self`, which refers to the instance of the class it belongs to. It returns a formatted string that includes the product's `id`, `name`, and `sku`, structured as `<Product(id=..., name='...', sku='...')>`. Developers use this function to obtain a clear and informative representation of product objects, which aids in understanding the object's state during development and troubleshooting. By implementing `__repr__`, it enhances the readability of object instances, making it easier to identify and debug issues related to product attributes."
    },
    {
      "type": "function",
      "name": "is_in_stock",
      "content": "    def is_in_stock(self) -> bool:\n        \"\"\"Check if product is in stock\"\"\"\n        return self.stock_quantity > 0",
      "metadata": {
        "file_path": "app/models/product.py",
        "chunk_type": "function",
        "name": "is_in_stock",
        "purpose": "Check if product is in stock",
        "dependencies": [],
        "access_level": "public",
        "function_name": "is_in_stock",
        "parameters": [
          "self"
        ],
        "return_type": "bool",
        "decorators": [
          "property"
        ],
        "is_async": false
      },
      "description": "The `is_in_stock` function is a method designed to determine if a product is available for sale by checking its stock quantity. It expects a single input parameter, `self`, which refers to the instance of the class containing this method. The function returns a boolean value: `True` if the product's stock quantity is greater than zero, indicating that the product is in stock, and `False` otherwise. Developers would use this function in inventory management systems or e-commerce applications to verify product availability before processing orders. It effectively solves the problem of ensuring that customers can only purchase items that are currently in stock, thereby preventing overselling and enhancing user experience."
    },
    {
      "type": "function",
      "name": "to_dict",
      "content": "    def to_dict(self) -> dict:\n        \"\"\"Convert product to dictionary\"\"\"\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"description\": self.description,\n            \"price\": float(self.price) if self.price else None,\n            \"sku\": self.sku,\n            \"stock_quantity\": self.stock_quantity,\n            \"is_active\": self.is_active,\n            \"is_in_stock\": self.is_in_stock,\n            \"weight\": float(self.weight) if self.weight else None,\n            \"dimensions\": self.dimensions,\n            \"category_id\": self.category_id,\n            \"created_at\": self.created_at.isoformat() if self.created_at else None,\n            \"updated_at\": self.updated_at.isoformat() if self.updated_at else None\n        }",
      "metadata": {
        "file_path": "app/models/product.py",
        "chunk_type": "function",
        "name": "to_dict",
        "purpose": "Convert product to dictionary",
        "dependencies": [],
        "access_level": "public",
        "function_name": "to_dict",
        "parameters": [
          "self"
        ],
        "return_type": "dict",
        "decorators": [],
        "is_async": false
      },
      "description": "The `to_dict` function is a method designed to convert a product object into a dictionary format. It expects a single input parameter, `self`, which refers to the instance of the product class. The function returns a dictionary containing key attributes of the product, including `id`, `name`, `description`, `price`, `sku`, `stock_quantity`, `is_active`, `is_in_stock`, `weight`, `dimensions`, `category_id`, and timestamps for `created_at` and `updated_at`. \n\nDevelopers would use this function when they need to serialize product data for APIs, data storage, or when interfacing with other systems that require a dictionary representation of product objects. It solves the problem of converting complex product instances into a simple, structured format that is easy to manipulate and transmit, ensuring that all relevant product information is captured in a consistent manner."
    },
    {
      "type": "function",
      "name": "__repr__",
      "content": "    def __repr__(self):\n        return f\"<ProductImage(id={self.id}, product_id={self.product_id}, url='{self.image_url}')>\"",
      "metadata": {
        "file_path": "app/models/product.py",
        "chunk_type": "function",
        "name": "__repr__",
        "purpose": "Function __repr__",
        "dependencies": [],
        "access_level": "public",
        "function_name": "__repr__",
        "parameters": [
          "self"
        ],
        "return_type": "",
        "decorators": [],
        "is_async": false
      },
      "description": "The `__repr__` function is a special method in Python designed to provide a formal string representation of an instance of a class, specifically for the `ProductImage` class. It takes a single parameter, `self`, which refers to the instance of the class. The function returns a string formatted to include the instance's `id`, `product_id`, and `image_url` attributes, encapsulated in angle brackets for clarity.\n\nDevelopers use this function primarily for debugging and logging purposes, as it allows for an easy-to-read representation of the object, making it simpler to inspect instances during development. By providing a clear output of the object's key attributes, it helps in understanding the state of the object at any given time.\n\nThis function solves the problem of unclear or uninformative default string representations of objects in Python, enhancing the readability and maintainability of the code."
    },
    {
      "type": "function",
      "name": "to_dict",
      "content": "    def to_dict(self) -> dict:\n        \"\"\"Convert product image to dictionary\"\"\"\n        return {\n            \"id\": self.id,\n            \"product_id\": self.product_id,\n            \"image_url\": self.image_url,\n            \"alt_text\": self.alt_text,\n            \"is_primary\": self.is_primary,\n            \"sort_order\": self.sort_order,\n            \"created_at\": self.created_at.isoformat() if self.created_at else None\n        }",
      "metadata": {
        "file_path": "app/models/product.py",
        "chunk_type": "function",
        "name": "to_dict",
        "purpose": "Convert product image to dictionary",
        "dependencies": [],
        "access_level": "public",
        "function_name": "to_dict",
        "parameters": [
          "self"
        ],
        "return_type": "dict",
        "decorators": [],
        "is_async": false
      },
      "description": "**Function Description: `to_dict`**\n\nThe `to_dict` function is a method designed to convert an instance of a product image into a dictionary format. It expects a single input parameter, `self`, which refers to the instance of the class containing the product image attributes. \n\nThis function returns a dictionary containing key attributes of the product image, including:\n- `id`: Unique identifier for the image.\n- `product_id`: Identifier linking the image to its associated product.\n- `image_url`: URL of the product image.\n- `alt_text`: Alternative text for the image, useful for accessibility.\n- `is_primary`: Boolean indicating if this image is the primary image for the product.\n- `sort_order`: Integer representing the order of the image in a list.\n- `created_at`: Timestamp of when the image was created, formatted in ISO 8601 if available.\n\nDevelopers would use this function when they need to serialize product image data for APIs, data storage, or front"
    },
    {
      "type": "imports",
      "name": "module_imports",
      "content": "Module Dependencies:\n\nThird Party: sqlalchemy\n  - Column, Integer, String, Text, Boolean, DateTime\n\nThird Party: sqlalchemy.sql\n  - func\n\nThird Party: sqlalchemy.orm\n  - relationship\n\nLocal: app.core.database\n  - Base",
      "metadata": {
        "file_path": "app/models/category.py",
        "chunk_type": "imports",
        "name": "module_imports",
        "purpose": "Module dependencies and imports",
        "dependencies": [],
        "access_level": "public",
        "imports": [
          {
            "module": "sqlalchemy",
            "type": "third_party",
            "items": [
              "Column",
              "Integer",
              "String",
              "Text",
              "Boolean",
              "DateTime"
            ]
          },
          {
            "module": "sqlalchemy.sql",
            "type": "third_party",
            "items": [
              "func"
            ]
          },
          {
            "module": "sqlalchemy.orm",
            "type": "third_party",
            "items": [
              "relationship"
            ]
          },
          {
            "module": "app.core.database",
            "type": "local",
            "items": [
              "Base"
            ]
          }
        ]
      },
      "description": "The `module_imports` Python module manages dependencies and imports essential for database operations within the application. It relies on the third-party library `sqlalchemy`, which provides key components such as `Column`, `Integer`, `String`, `Text`, `Boolean`, and `DateTime` for defining database schemas. Additionally, it imports `func` from `sqlalchemy.sql` for executing SQL functions and `relationship` from `sqlalchemy.orm` to establish relationships between database entities.\n\nThe module also incorporates a local dependency, `Base` from `app.core.database`, which serves as the declarative base class for defining ORM models. This setup enables seamless interaction with the database, facilitating CRUD operations and data management.\n\nOverall, the `module_imports` module integrates third-party and local components to enhance the application's database functionality, leveraging SQLAlchemy's robust ORM capabilities for efficient data handling."
    },
    {
      "type": "class",
      "name": "Category",
      "content": "class Category:\n    # Inherits from: Base\n    # Purpose: Category model\n\n    def __repr__(self, ...):\n        # Method implementation\n\n    def product_count(self, ...):\n        # Method implementation\n\n    def to_dict(self, ...):\n        # Method implementation",
      "metadata": {
        "file_path": "app/models/category.py",
        "chunk_type": "class",
        "name": "Category",
        "purpose": "Category model",
        "dependencies": [],
        "access_level": "public",
        "class_name": "Category",
        "methods": [
          "__repr__",
          "product_count",
          "to_dict"
        ],
        "attributes": [],
        "base_classes": [
          "Base"
        ],
        "decorators": []
      },
      "description": "**Description of the Category Class**\n\nThe `Category` class represents a model for categorizing products within a system, typically used in e-commerce or inventory management applications. It provides a structured way to organize products into distinct categories, facilitating better product management and user navigation.\n\nKey functionalities include:\n- **`__repr__` Method**: Offers a string representation of the category instance, aiding in debugging and logging.\n- **`product_count` Method**: Calculates and returns the number of products associated with the category, helping developers assess category popularity and inventory levels.\n- **`to_dict` Method**: Converts the category instance into a dictionary format, which is useful for data serialization and API responses.\n\nDevelopers would use this class when building applications that require product categorization, enhancing user experience and data organization. It fits into the system as a foundational component for managing product data and improving the overall structure of the application."
    },
    {
      "type": "function",
      "name": "__repr__",
      "content": "    def __repr__(self):\n        return f\"<Category(id={self.id}, name='{self.name}', slug='{self.slug}')>\"",
      "metadata": {
        "file_path": "app/models/category.py",
        "chunk_type": "function",
        "name": "__repr__",
        "purpose": "Function __repr__",
        "dependencies": [],
        "access_level": "public",
        "function_name": "__repr__",
        "parameters": [
          "self"
        ],
        "return_type": "",
        "decorators": [],
        "is_async": false
      },
      "description": "The `__repr__` function in Python is a special method that provides a string representation of an object, primarily for debugging and logging purposes. This implementation expects a single parameter, `self`, which refers to the instance of the class. It returns a formatted string that includes the object's `id`, `name`, and `slug` attributes, structured as `<Category(id=..., name='...', slug='...')>`.\n\nDevelopers use this function to gain a clear and informative representation of `Category` objects, making it easier to inspect their state during development or when troubleshooting. By providing a concise overview of the object's key attributes, it helps in understanding the data structure and facilitates debugging, thereby solving the problem of unclear or uninformative object representations."
    },
    {
      "type": "function",
      "name": "product_count",
      "content": "    def product_count(self) -> int:\n        \"\"\"Get number of products in this category\"\"\"\n        return len(self.products)",
      "metadata": {
        "file_path": "app/models/category.py",
        "chunk_type": "function",
        "name": "product_count",
        "purpose": "Get number of products in this category",
        "dependencies": [],
        "access_level": "public",
        "function_name": "product_count",
        "parameters": [
          "self"
        ],
        "return_type": "int",
        "decorators": [
          "property"
        ],
        "is_async": false
      },
      "description": "**Function Description: `product_count`**\n\nThe `product_count` function is designed to retrieve the total number of products within a specific category. It takes a single parameter, `self`, which refers to the instance of the class containing the `products` attribute. This function returns an integer representing the count of products, calculated using the `len()` function on the `self.products` list.\n\nDevelopers would use this function when they need to quickly assess the size of a product category, such as for inventory management, displaying product counts in user interfaces, or performing analytics on product availability. By providing a straightforward way to access product counts, this function helps streamline category management and enhances data-driven decision-making in applications involving product catalogs."
    },
    {
      "type": "function",
      "name": "to_dict",
      "content": "    def to_dict(self) -> dict:\n        \"\"\"Convert category to dictionary\"\"\"\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"slug\": self.slug,\n            \"description\": self.description,\n            \"parent_id\": self.parent_id,\n            \"is_active\": self.is_active,\n            \"sort_order\": self.sort_order,\n            \"product_count\": self.product_count,\n            \"created_at\": self.created_at.isoformat() if self.created_at else None,\n            \"updated_at\": self.updated_at.isoformat() if self.updated_at else None\n        }",
      "metadata": {
        "file_path": "app/models/category.py",
        "chunk_type": "function",
        "name": "to_dict",
        "purpose": "Convert category to dictionary",
        "dependencies": [],
        "access_level": "public",
        "function_name": "to_dict",
        "parameters": [
          "self"
        ],
        "return_type": "dict",
        "decorators": [],
        "is_async": false
      },
      "description": "The `to_dict` function is a method designed to convert an instance of a category class into a dictionary format. It expects a single parameter, `self`, which refers to the instance of the class. The function returns a dictionary containing key attributes of the category, including `id`, `name`, `slug`, `description`, `parent_id`, `is_active`, `sort_order`, `product_count`, and timestamps for `created_at` and `updated_at`. Developers would use this function when they need to serialize category objects for data interchange, such as in APIs or for storage in JSON format. It solves the problem of transforming complex objects into a simple, structured format that is easy to work with in various applications."
    },
    {
      "type": "imports",
      "name": "module_imports",
      "content": "Module Dependencies:\n\nStandard Library: typing\n  - Optional\n\nThird Party: pydantic\n  - BaseModel, EmailStr, validator",
      "metadata": {
        "file_path": "app/schemas/user.py",
        "chunk_type": "imports",
        "name": "module_imports",
        "purpose": "Module dependencies and imports",
        "dependencies": [],
        "access_level": "public",
        "imports": [
          {
            "module": "typing",
            "type": "standard",
            "items": [
              "Optional"
            ]
          },
          {
            "module": "pydantic",
            "type": "third_party",
            "items": [
              "BaseModel",
              "EmailStr",
              "validator"
            ]
          }
        ]
      },
      "description": "The `module_imports` Python module manages dependencies and imports essential for its functionality. It relies on the standard library module `typing`, specifically the `Optional` type, which allows for type hinting of variables that may or may not hold a value. Additionally, it incorporates the third-party library `pydantic`, utilizing its `BaseModel` for data validation and settings management, `EmailStr` for email address validation, and the `validator` decorator to define custom validation logic. This module plays a critical role in ensuring robust data handling within the system, leveraging external libraries to enhance type safety and validation processes."
    },
    {
      "type": "class",
      "name": "UserBase",
      "content": "class UserBase:\n    # Inherits from: BaseModel\n    # Purpose: Base user schema",
      "metadata": {
        "file_path": "app/schemas/user.py",
        "chunk_type": "class",
        "name": "UserBase",
        "purpose": "Base user schema",
        "dependencies": [],
        "access_level": "public",
        "class_name": "UserBase",
        "methods": [],
        "attributes": [],
        "base_classes": [
          "BaseModel"
        ],
        "decorators": []
      },
      "description": "**Description of UserBase Class:**\n\nThe `UserBase` class serves as a foundational schema for user-related data in a system, inheriting from `BaseModel`. It establishes a standard structure for user attributes, facilitating consistency across user data management. This class addresses the need for a unified user model, simplifying the implementation of user-related functionalities in applications. Developers would utilize `UserBase` when creating user management systems, ensuring that all user entities adhere to a common schema. Its role in the system is crucial, as it lays the groundwork for more complex user models and operations, promoting code reusability and maintainability."
    },
    {
      "type": "class",
      "name": "UserCreate",
      "content": "class UserCreate:\n    # Inherits from: UserBase\n    # Purpose: User creation schema\n\n    def validate_password(self, ...):\n        # Method implementation\n\n    def validate_username(self, ...):\n        # Method implementation",
      "metadata": {
        "file_path": "app/schemas/user.py",
        "chunk_type": "class",
        "name": "UserCreate",
        "purpose": "User creation schema",
        "dependencies": [],
        "access_level": "public",
        "class_name": "UserCreate",
        "methods": [
          "validate_password",
          "validate_username"
        ],
        "attributes": [],
        "base_classes": [
          "UserBase"
        ],
        "decorators": []
      },
      "description": "**Description of UserCreate Class:**\n\nThe `UserCreate` class is a schema designed for creating new user accounts within an application. It inherits from the `UserBase` class, ensuring that it maintains foundational user attributes while adding specific validation methods. The class includes two key methods: `validate_password` and `validate_username`, which are responsible for ensuring that user inputs meet predefined criteria for security and uniqueness. \n\nThis class addresses common problems in user registration, such as enforcing strong password policies and preventing duplicate usernames, thereby enhancing user data integrity and security. Developers would use this class during the user registration process in web applications or APIs, ensuring that new users are created with valid and secure credentials. \n\nBy integrating with the overall user management system, the `UserCreate` class plays a crucial role in maintaining a robust and secure user authentication framework."
    },
    {
      "type": "class",
      "name": "UserUpdate",
      "content": "class UserUpdate:\n    # Inherits from: BaseModel\n    # Purpose: User update schema",
      "metadata": {
        "file_path": "app/schemas/user.py",
        "chunk_type": "class",
        "name": "UserUpdate",
        "purpose": "User update schema",
        "dependencies": [],
        "access_level": "public",
        "class_name": "UserUpdate",
        "methods": [],
        "attributes": [],
        "base_classes": [
          "BaseModel"
        ],
        "decorators": []
      },
      "description": "**Description of the UserUpdate Class**\n\nThe `UserUpdate` class is a schema designed for managing user updates within an application. It inherits from `BaseModel`, ensuring it adheres to a structured format for data validation and serialization. This class serves to encapsulate the attributes and requirements necessary for updating user information, thereby streamlining the process of modifying user profiles.\n\nDevelopers would utilize the `UserUpdate` class when implementing features that require user data modifications, such as profile editing or account settings adjustments. By providing a clear schema, it helps prevent errors and ensures that only valid data is processed during updates.\n\nIn the broader system, the `UserUpdate` class plays a critical role in maintaining data integrity and consistency, facilitating seamless interactions between the user interface and the backend database. It is particularly useful in RESTful APIs where structured data representation is essential for effective communication between client and server."
    },
    {
      "type": "class",
      "name": "UserResponse",
      "content": "class UserResponse:\n    # Inherits from: UserBase\n    # Purpose: User response schema",
      "metadata": {
        "file_path": "app/schemas/user.py",
        "chunk_type": "class",
        "name": "UserResponse",
        "purpose": "User response schema",
        "dependencies": [],
        "access_level": "public",
        "class_name": "UserResponse",
        "methods": [],
        "attributes": [],
        "base_classes": [
          "UserBase"
        ],
        "decorators": []
      },
      "description": "**Description:**\n\nThe `UserResponse` class is a schema designed to represent user responses within an application, inheriting properties and methods from the `UserBase` class. This class serves as a structured format for encapsulating user-related data, facilitating data validation and consistency across the system. Developers would utilize this class when implementing features that require standardized user response handling, such as API responses or data serialization. By providing a clear and consistent schema, `UserResponse` enhances maintainability and interoperability within the application, ensuring that user data is accurately represented and easily processed."
    },
    {
      "type": "class",
      "name": "UserLogin",
      "content": "class UserLogin:\n    # Inherits from: BaseModel\n    # Purpose: User login schema",
      "metadata": {
        "file_path": "app/schemas/user.py",
        "chunk_type": "class",
        "name": "UserLogin",
        "purpose": "User login schema",
        "dependencies": [],
        "access_level": "public",
        "class_name": "UserLogin",
        "methods": [],
        "attributes": [],
        "base_classes": [
          "BaseModel"
        ],
        "decorators": []
      },
      "description": "**Description of UserLogin Class:**\n\nThe `UserLogin` class represents a schema for user authentication in a software application, inheriting from `BaseModel`. It serves as a foundational structure for managing user login data, ensuring that the necessary attributes for user authentication are defined and validated. This class addresses the problem of securely handling user credentials and streamlining the login process, making it essential for applications requiring user authentication.\n\nDevelopers would use the `UserLogin` class when implementing user login functionality, particularly in systems that require a standardized approach to managing user credentials. It fits into the overall system architecture by providing a clear and organized method for handling user login data, which can be easily integrated with authentication services and databases.\n\nThis class is particularly useful in web applications, mobile apps, or any software that necessitates user login features, promoting consistency and security in user authentication processes."
    },
    {
      "type": "class",
      "name": "Token",
      "content": "class Token:\n    # Inherits from: BaseModel\n    # Purpose: Token response schema",
      "metadata": {
        "file_path": "app/schemas/user.py",
        "chunk_type": "class",
        "name": "Token",
        "purpose": "Token response schema",
        "dependencies": [],
        "access_level": "public",
        "class_name": "Token",
        "methods": [],
        "attributes": [],
        "base_classes": [
          "BaseModel"
        ],
        "decorators": []
      },
      "description": "**Description of the Token Class:**\n\nThe `Token` class represents a schema for token responses in a system, inheriting from `BaseModel`. It serves as a structured format for managing and validating token-related data, which is essential in authentication and authorization processes. By defining a clear schema, it helps developers ensure consistency and integrity in token handling, thereby solving issues related to data validation and interoperability between different components of an application. Developers would use this class when implementing features that require token generation, storage, or validation, particularly in secure API interactions. Its integration into the broader system enhances the overall architecture by providing a standardized approach to token management, facilitating easier maintenance and scalability."
    },
    {
      "type": "class",
      "name": "Config",
      "content": "class Config:\n    # Purpose: No description available",
      "metadata": {
        "file_path": "app/schemas/user.py",
        "chunk_type": "class",
        "name": "Config",
        "purpose": "Class Config",
        "dependencies": [],
        "access_level": "public",
        "class_name": "Config",
        "methods": [],
        "attributes": [],
        "base_classes": [],
        "decorators": []
      },
      "description": "**Description of Class Config**\n\nThe `Config` class serves as a placeholder for configuration settings within a Python application. Although it currently contains no methods or attributes, it is designed to encapsulate configuration-related data, making it easier for developers to manage application settings in a centralized manner. This class can be extended in the future to include methods for loading, validating, and accessing configuration parameters, thereby solving the problem of scattered configuration management across the codebase.\n\nDevelopers would use the `Config` class when they need a structured way to handle application configurations, especially in larger projects where settings may need to be modified or accessed frequently. It fits into the overall system architecture by providing a dedicated space for configuration logic, promoting cleaner code and enhancing maintainability."
    },
    {
      "type": "function",
      "name": "validate_password",
      "content": "    def validate_password(cls, v):\n        if len(v) < 8:\n            raise ValueError('Password must be at least 8 characters long')\n        return v",
      "metadata": {
        "file_path": "app/schemas/user.py",
        "chunk_type": "function",
        "name": "validate_password",
        "purpose": "Function validate_password",
        "dependencies": [],
        "access_level": "public",
        "function_name": "validate_password",
        "parameters": [
          "cls",
          "v"
        ],
        "return_type": "",
        "decorators": [
          "validator('password')"
        ],
        "is_async": false
      },
      "description": "The `validate_password` function is a Python method designed to enforce password strength requirements. It takes two parameters: `cls`, which typically refers to the class context in a class method, and `v`, which is the password string to be validated. The function checks if the length of the password `v` is at least 8 characters. If the password does not meet this requirement, it raises a `ValueError` with an appropriate message. If the password is valid, it returns the original password string `v`. \n\nDevelopers would use this function when implementing user authentication systems to ensure that passwords meet minimum security standards, thereby enhancing overall application security. This function addresses the common issue of weak passwords by enforcing a basic length requirement, helping to prevent unauthorized access and improve user account safety."
    },
    {
      "type": "function",
      "name": "validate_username",
      "content": "    def validate_username(cls, v):\n        if len(v) < 3:\n            raise ValueError('Username must be at least 3 characters long')\n        return v",
      "metadata": {
        "file_path": "app/schemas/user.py",
        "chunk_type": "function",
        "name": "validate_username",
        "purpose": "Function validate_username",
        "dependencies": [],
        "access_level": "public",
        "function_name": "validate_username",
        "parameters": [
          "cls",
          "v"
        ],
        "return_type": "",
        "decorators": [
          "validator('username')"
        ],
        "is_async": false
      },
      "description": "The `validate_username` function is a class method designed to validate user-provided usernames. It accepts two parameters: `cls`, which refers to the class itself, and `v`, the username string to be validated. The function checks if the length of the username `v` is less than 3 characters; if so, it raises a `ValueError` with a message indicating that the username must be at least 3 characters long. If the username meets the length requirement, it returns the valid username. Developers would use this function during user registration or profile updates to ensure that usernames adhere to minimum length constraints, thereby preventing issues related to short or invalid usernames. This function effectively helps maintain data integrity and improves user experience by enforcing username standards."
    },
    {
      "type": "imports",
      "name": "module_imports",
      "content": "Module Dependencies:\n\nStandard Library: typing\n  - Optional, List\n\nThird Party: decimal\n  - Decimal\n\nThird Party: pydantic\n  - BaseModel, validator\n\nLocal: app.models.order\n  - OrderStatus",
      "metadata": {
        "file_path": "app/schemas/order.py",
        "chunk_type": "imports",
        "name": "module_imports",
        "purpose": "Module dependencies and imports",
        "dependencies": [],
        "access_level": "public",
        "imports": [
          {
            "module": "typing",
            "type": "standard",
            "items": [
              "Optional",
              "List"
            ]
          },
          {
            "module": "decimal",
            "type": "third_party",
            "items": [
              "Decimal"
            ]
          },
          {
            "module": "pydantic",
            "type": "third_party",
            "items": [
              "BaseModel",
              "validator"
            ]
          },
          {
            "module": "app.models.order",
            "type": "local",
            "items": [
              "OrderStatus"
            ]
          }
        ]
      },
      "description": "The `module_imports` Python module serves as a central hub for managing dependencies and imports essential for its functionality. It utilizes the standard library's `typing` module, specifically `Optional` and `List`, to enhance type annotations and improve code clarity. The module also incorporates the third-party library `decimal`, leveraging the `Decimal` class for precise numerical operations, particularly useful in financial calculations.\n\nAdditionally, it employs `pydantic`, importing `BaseModel` and `validator` to facilitate data validation and settings management, ensuring that data structures adhere to defined schemas. This module further integrates a local dependency from `app.models.order`, specifically `OrderStatus`, which likely represents various states of an order within the application.\n\nOverall, `module_imports` provides a structured approach to dependency management, enhancing the robustness and maintainability of the system by relying on both standard and third-party libraries. Its use of `pydantic` and `decimal` indicates a focus on data integrity and precision, making"
    },
    {
      "type": "class",
      "name": "OrderItemBase",
      "content": "class OrderItemBase:\n    # Inherits from: BaseModel\n    # Purpose: Base order item schema",
      "metadata": {
        "file_path": "app/schemas/order.py",
        "chunk_type": "class",
        "name": "OrderItemBase",
        "purpose": "Base order item schema",
        "dependencies": [],
        "access_level": "public",
        "class_name": "OrderItemBase",
        "methods": [],
        "attributes": [],
        "base_classes": [
          "BaseModel"
        ],
        "decorators": []
      },
      "description": "**Description of OrderItemBase Class:**\n\nThe `OrderItemBase` class serves as a foundational schema for order items in an e-commerce or order management system. By inheriting from `BaseModel`, it establishes a standardized structure for order items, ensuring consistency across various implementations. This class addresses the need for a clear and organized representation of order items, facilitating data management and manipulation within the system.\n\nDevelopers would utilize `OrderItemBase` when creating specific order item types, allowing for easy extension and customization while maintaining a cohesive architecture. Its role as a base class makes it integral to the overall system, promoting code reusability and simplifying the development process for order-related functionalities."
    },
    {
      "type": "class",
      "name": "OrderItemCreate",
      "content": "class OrderItemCreate:\n    # Inherits from: OrderItemBase\n    # Purpose: Order item creation schema\n\n    def validate_quantity(self, ...):\n        # Method implementation",
      "metadata": {
        "file_path": "app/schemas/order.py",
        "chunk_type": "class",
        "name": "OrderItemCreate",
        "purpose": "Order item creation schema",
        "dependencies": [],
        "access_level": "public",
        "class_name": "OrderItemCreate",
        "methods": [
          "validate_quantity"
        ],
        "attributes": [],
        "base_classes": [
          "OrderItemBase"
        ],
        "decorators": []
      },
      "description": "**Class Description: OrderItemCreate**\n\nThe `OrderItemCreate` class serves as a schema for creating order items within an e-commerce or inventory management system. It inherits from the `OrderItemBase` class, ensuring a structured approach to defining order item attributes. The primary method, `validate_quantity`, is designed to enforce business rules regarding the quantity of items being ordered, preventing invalid or excessive orders.\n\nThis class addresses common challenges in order processing, such as ensuring that the quantity of items adheres to predefined limits and business logic. Developers would utilize `OrderItemCreate` when implementing order creation features in applications, ensuring data integrity and compliance with operational requirements.\n\nBy integrating this class into the system, developers can streamline the order creation process, enhance validation mechanisms, and maintain consistency across order-related functionalities."
    },
    {
      "type": "class",
      "name": "OrderItemResponse",
      "content": "class OrderItemResponse:\n    # Inherits from: OrderItemBase\n    # Purpose: Order item response schema",
      "metadata": {
        "file_path": "app/schemas/order.py",
        "chunk_type": "class",
        "name": "OrderItemResponse",
        "purpose": "Order item response schema",
        "dependencies": [],
        "access_level": "public",
        "class_name": "OrderItemResponse",
        "methods": [],
        "attributes": [],
        "base_classes": [
          "OrderItemBase"
        ],
        "decorators": []
      },
      "description": "**Description of OrderItemResponse Class**\n\nThe `OrderItemResponse` class serves as a schema for representing the response structure of an order item in a system. It inherits from the `OrderItemBase` class, ensuring that it maintains a consistent base structure while allowing for specific enhancements related to order item responses. This class addresses the need for a standardized format when returning order item details, facilitating easier data handling and integration with APIs.\n\nDevelopers would utilize the `OrderItemResponse` class when implementing features that require the retrieval or display of order item information, such as e-commerce platforms or inventory management systems. By providing a clear and consistent response format, it simplifies the process of managing order-related data and enhances the overall user experience.\n\nIn the broader system architecture, this class fits into the data response layer, acting as a bridge between the business logic and the presentation layer, ensuring that order item details are accurately conveyed to clients or front-end applications."
    },
    {
      "type": "class",
      "name": "OrderBase",
      "content": "class OrderBase:\n    # Inherits from: BaseModel\n    # Purpose: Base order schema",
      "metadata": {
        "file_path": "app/schemas/order.py",
        "chunk_type": "class",
        "name": "OrderBase",
        "purpose": "Base order schema",
        "dependencies": [],
        "access_level": "public",
        "class_name": "OrderBase",
        "methods": [],
        "attributes": [],
        "base_classes": [
          "BaseModel"
        ],
        "decorators": []
      },
      "description": "**Description:**\n\nThe `OrderBase` class serves as a foundational schema for order management in a system, inheriting from `BaseModel`. It provides a structured template for order-related data, ensuring consistency and standardization across different order implementations. This class addresses the need for a unified representation of orders, simplifying the development process by allowing developers to extend or customize order functionalities without redefining core attributes. Developers would utilize `OrderBase` when creating specific order types or integrating order processing features into their applications. Its role in the system is crucial, as it establishes a common interface for order data, facilitating easier data handling, validation, and interaction with other components of the order management system."
    },
    {
      "type": "class",
      "name": "OrderCreate",
      "content": "class OrderCreate:\n    # Inherits from: OrderBase\n    # Purpose: Order creation schema\n\n    def validate_items(self, ...):\n        # Method implementation",
      "metadata": {
        "file_path": "app/schemas/order.py",
        "chunk_type": "class",
        "name": "OrderCreate",
        "purpose": "Order creation schema",
        "dependencies": [],
        "access_level": "public",
        "class_name": "OrderCreate",
        "methods": [
          "validate_items"
        ],
        "attributes": [],
        "base_classes": [
          "OrderBase"
        ],
        "decorators": []
      },
      "description": "**Class Description: OrderCreate**\n\nThe `OrderCreate` class serves as a schema for creating new orders in an application. It inherits from the `OrderBase` class, ensuring that it maintains foundational order attributes while adding specific functionalities for order creation. \n\nThis class addresses the need for structured order data validation, particularly through its `validate_items` method, which ensures that the items included in an order meet predefined criteria. Developers would utilize this class when implementing order creation features in e-commerce platforms or inventory management systems, where ensuring data integrity and validation is crucial.\n\nBy fitting into the broader order management system, the `OrderCreate` class streamlines the process of capturing and validating order details, ultimately enhancing user experience and reducing errors during order submission."
    },
    {
      "type": "class",
      "name": "OrderUpdate",
      "content": "class OrderUpdate:\n    # Inherits from: BaseModel\n    # Purpose: Order update schema",
      "metadata": {
        "file_path": "app/schemas/order.py",
        "chunk_type": "class",
        "name": "OrderUpdate",
        "purpose": "Order update schema",
        "dependencies": [],
        "access_level": "public",
        "class_name": "OrderUpdate",
        "methods": [],
        "attributes": [],
        "base_classes": [
          "BaseModel"
        ],
        "decorators": []
      },
      "description": "**Class Description: OrderUpdate**\n\nThe `OrderUpdate` class represents a schema for updating order information within an application. It inherits from `BaseModel`, providing a structured way to define and validate order update data. This class addresses the need for a standardized format when modifying existing orders, ensuring data integrity and consistency.\n\nDevelopers would use the `OrderUpdate` class when implementing features that require order modifications, such as changing order status, updating quantities, or altering delivery details. It fits into the system as part of the broader order management functionality, facilitating seamless updates and interactions with order data in a reliable manner."
    },
    {
      "type": "class",
      "name": "OrderResponse",
      "content": "class OrderResponse:\n    # Inherits from: OrderBase\n    # Purpose: Order response schema",
      "metadata": {
        "file_path": "app/schemas/order.py",
        "chunk_type": "class",
        "name": "OrderResponse",
        "purpose": "Order response schema",
        "dependencies": [],
        "access_level": "public",
        "class_name": "OrderResponse",
        "methods": [],
        "attributes": [],
        "base_classes": [
          "OrderBase"
        ],
        "decorators": []
      },
      "description": "**Description of the OrderResponse Class:**\n\nThe `OrderResponse` class serves as a schema for representing responses related to order processing in a system. It inherits from the `OrderBase` class, indicating that it builds upon foundational order attributes and behaviors. This class addresses the need for a structured format to encapsulate order response data, ensuring consistency and clarity in how order-related information is communicated back to the client or user interface.\n\nDevelopers would utilize the `OrderResponse` class when implementing features that require the handling of order confirmations, updates, or status inquiries. By providing a clear schema, it simplifies the process of managing order data, thereby reducing errors and improving maintainability.\n\nIn the broader system architecture, the `OrderResponse` class fits into the order management module, facilitating seamless interactions between the order processing logic and the presentation layer, ultimately enhancing the user experience in e-commerce or order fulfillment applications."
    },
    {
      "type": "class",
      "name": "OrderListResponse",
      "content": "class OrderListResponse:\n    # Inherits from: BaseModel\n    # Purpose: Order list response schema",
      "metadata": {
        "file_path": "app/schemas/order.py",
        "chunk_type": "class",
        "name": "OrderListResponse",
        "purpose": "Order list response schema",
        "dependencies": [],
        "access_level": "public",
        "class_name": "OrderListResponse",
        "methods": [],
        "attributes": [],
        "base_classes": [
          "BaseModel"
        ],
        "decorators": []
      },
      "description": "**Description:**\n\nThe `OrderListResponse` class is a schema representation for the response structure of an order list in a system, inheriting from `BaseModel`. It serves to standardize the format of order list data returned from APIs, ensuring consistency in how order information is presented to clients. This class addresses the need for a clear and structured response format, simplifying data handling and integration for developers working with order management systems. Developers would utilize this class when implementing or consuming APIs that require a defined response for order lists, facilitating easier data parsing and manipulation. It fits into the overall system architecture by acting as a data model that enhances communication between the backend and frontend, promoting efficient data exchange and reducing errors in order-related operations."
    },
    {
      "type": "class",
      "name": "Config",
      "content": "class Config:\n    # Purpose: No description available",
      "metadata": {
        "file_path": "app/schemas/order.py",
        "chunk_type": "class",
        "name": "Config",
        "purpose": "Class Config",
        "dependencies": [],
        "access_level": "public",
        "class_name": "Config",
        "methods": [],
        "attributes": [],
        "base_classes": [],
        "decorators": []
      },
      "description": "**Description of the Config Class:**\n\nThe `Config` class serves as a placeholder for configuration settings within a Python application. Although it currently contains no methods or attributes, it is designed to encapsulate configuration-related data, making it easier to manage application settings in a centralized manner. Developers would use this class when they need a structured way to handle configurations, especially in larger systems where settings may need to be accessed or modified frequently. By providing a dedicated class for configurations, it enhances code organization and maintainability, allowing for future expansion with methods to load, save, or validate configuration data. This class fits into the system as a foundational component that can be built upon to support dynamic configuration management."
    },
    {
      "type": "class",
      "name": "Config",
      "content": "class Config:\n    # Purpose: No description available",
      "metadata": {
        "file_path": "app/schemas/order.py",
        "chunk_type": "class",
        "name": "Config",
        "purpose": "Class Config",
        "dependencies": [],
        "access_level": "public",
        "class_name": "Config",
        "methods": [],
        "attributes": [],
        "base_classes": [],
        "decorators": []
      },
      "description": "**Description of the Config Class:**\n\nThe `Config` class serves as a placeholder for configuration settings within a software application. Although it currently contains no methods or attributes, its purpose is to provide a structured way to manage application settings, which can be expanded in the future. Developers would use this class when they need a centralized location to store configuration parameters, making it easier to maintain and modify settings without altering the core application logic. This class fits into the system as a foundational component that can be integrated with other modules requiring configuration management, thus enhancing code organization and readability."
    },
    {
      "type": "function",
      "name": "validate_quantity",
      "content": "    def validate_quantity(cls, v):\n        if v <= 0:\n            raise ValueError('Quantity must be greater than 0')\n        return v",
      "metadata": {
        "file_path": "app/schemas/order.py",
        "chunk_type": "function",
        "name": "validate_quantity",
        "purpose": "Function validate_quantity",
        "dependencies": [],
        "access_level": "public",
        "function_name": "validate_quantity",
        "parameters": [
          "cls",
          "v"
        ],
        "return_type": "",
        "decorators": [
          "validator('quantity')"
        ],
        "is_async": false
      },
      "description": "The `validate_quantity` function is a Python method designed to ensure that a given quantity, represented by the parameter `v`, is a positive number. It takes two parameters: `cls`, which typically refers to the class context in which the method is called, and `v`, the value to be validated. If `v` is less than or equal to zero, the function raises a `ValueError` with the message 'Quantity must be greater than 0'. If the validation passes, it returns the original value `v`. Developers would use this function in scenarios where input validation is crucial, such as in inventory management or order processing systems, to prevent negative or zero quantities that could lead to logical errors or exceptions in the application. This function effectively solves the problem of ensuring data integrity by enforcing constraints on numerical inputs."
    },
    {
      "type": "function",
      "name": "validate_items",
      "content": "    def validate_items(cls, v):\n        if not v:\n            raise ValueError('Order must have at least one item')\n        return v",
      "metadata": {
        "file_path": "app/schemas/order.py",
        "chunk_type": "function",
        "name": "validate_items",
        "purpose": "Function validate_items",
        "dependencies": [],
        "access_level": "public",
        "function_name": "validate_items",
        "parameters": [
          "cls",
          "v"
        ],
        "return_type": "",
        "decorators": [
          "validator('items')"
        ],
        "is_async": false
      },
      "description": "**Description of `validate_items` Function:**\n\nThe `validate_items` function is designed to ensure that a given order contains at least one item. It takes two parameters: `cls`, which typically represents the class context, and `v`, which is expected to be a list or collection of items. If `v` is empty or evaluates to false, the function raises a `ValueError` with the message 'Order must have at least one item'. If `v` contains items, it returns the original value of `v`. \n\nDevelopers would use this function in scenarios where validating the presence of items in an order is critical, such as in e-commerce applications or inventory management systems. It effectively prevents errors related to processing empty orders, ensuring data integrity and improving user experience by enforcing necessary constraints."
    },
    {
      "type": "imports",
      "name": "module_imports",
      "content": "Module Dependencies:\n\nLocal: app.schemas.user\n  - UserCreate, UserUpdate, UserResponse, UserLogin\n\nLocal: app.schemas.product\n  - ProductCreate, ProductUpdate, ProductResponse, ProductImageCreate\n\nLocal: app.schemas.order\n  - OrderCreate, OrderUpdate, OrderResponse, OrderItemCreate\n\nLocal: app.schemas.category\n  - CategoryCreate, CategoryUpdate, CategoryResponse",
      "metadata": {
        "file_path": "app/schemas/__init__.py",
        "chunk_type": "imports",
        "name": "module_imports",
        "purpose": "Module dependencies and imports",
        "dependencies": [],
        "access_level": "public",
        "imports": [
          {
            "module": "app.schemas.user",
            "type": "local",
            "items": [
              "UserCreate",
              "UserUpdate",
              "UserResponse",
              "UserLogin"
            ]
          },
          {
            "module": "app.schemas.product",
            "type": "local",
            "items": [
              "ProductCreate",
              "ProductUpdate",
              "ProductResponse",
              "ProductImageCreate"
            ]
          },
          {
            "module": "app.schemas.order",
            "type": "local",
            "items": [
              "OrderCreate",
              "OrderUpdate",
              "OrderResponse",
              "OrderItemCreate"
            ]
          },
          {
            "module": "app.schemas.category",
            "type": "local",
            "items": [
              "CategoryCreate",
              "CategoryUpdate",
              "CategoryResponse"
            ]
          }
        ]
      },
      "description": "The `module_imports` Python module manages dependencies and imports related to user, product, order, and category schemas within an application. It imports local schema classes for creating, updating, and responding to user, product, order, and category data structures. \n\n**Dependencies:**\n- **User Schema:** Imports `UserCreate`, `UserUpdate`, `UserResponse`, and `UserLogin` from `app.schemas.user`.\n- **Product Schema:** Imports `ProductCreate`, `ProductUpdate`, `ProductResponse`, and `ProductImageCreate` from `app.schemas.product`.\n- **Order Schema:** Imports `OrderCreate`, `OrderUpdate`, `OrderResponse`, and `OrderItemCreate` from `app.schemas.order`.\n- **Category Schema:** Imports `CategoryCreate`, `CategoryUpdate`, and `CategoryResponse` from `app.schemas.category`.\n\n**Functionality:** This module provides structured data handling for user, product, order, and category entities, facilitating operations like creation, updates, and responses"
    },
    {
      "type": "imports",
      "name": "module_imports",
      "content": "Module Dependencies:\n\nStandard Library: typing\n  - Optional, List\n\nThird Party: decimal\n  - Decimal\n\nThird Party: pydantic\n  - BaseModel, validator",
      "metadata": {
        "file_path": "app/schemas/product.py",
        "chunk_type": "imports",
        "name": "module_imports",
        "purpose": "Module dependencies and imports",
        "dependencies": [],
        "access_level": "public",
        "imports": [
          {
            "module": "typing",
            "type": "standard",
            "items": [
              "Optional",
              "List"
            ]
          },
          {
            "module": "decimal",
            "type": "third_party",
            "items": [
              "Decimal"
            ]
          },
          {
            "module": "pydantic",
            "type": "third_party",
            "items": [
              "BaseModel",
              "validator"
            ]
          }
        ]
      },
      "description": "The `module_imports` Python module manages its dependencies and imports essential for its functionality. It relies on the standard library's `typing` module, specifically utilizing `Optional` and `List` for type hinting, which enhances code readability and type safety. \n\nAdditionally, the module incorporates the third-party `decimal` library, leveraging the `Decimal` class for precise decimal arithmetic, crucial for financial calculations or scenarios requiring high precision. It also utilizes the `pydantic` library, importing `BaseModel` and `validator` to facilitate data validation and settings management through Python data classes, ensuring robust data integrity.\n\nThis module serves as a foundational component within a larger system, providing structured data handling and validation capabilities while integrating seamlessly with external libraries to enhance its functionality."
    },
    {
      "type": "class",
      "name": "ProductImageBase",
      "content": "class ProductImageBase:\n    # Inherits from: BaseModel\n    # Purpose: Base product image schema",
      "metadata": {
        "file_path": "app/schemas/product.py",
        "chunk_type": "class",
        "name": "ProductImageBase",
        "purpose": "Base product image schema",
        "dependencies": [],
        "access_level": "public",
        "class_name": "ProductImageBase",
        "methods": [],
        "attributes": [],
        "base_classes": [
          "BaseModel"
        ],
        "decorators": []
      },
      "description": "**Description for ProductImageBase Class:**\n\nThe `ProductImageBase` class serves as a foundational schema for managing product images within an application. It inherits from `BaseModel`, establishing a structured template for product image attributes and behaviors. This class addresses the need for a standardized representation of product images, ensuring consistency across different product listings. Developers would utilize this class when building e-commerce platforms or inventory management systems where product imagery is essential for user engagement and sales conversion. By providing a base structure, `ProductImageBase` facilitates the extension and customization of product image handling, integrating seamlessly into the overall system architecture for enhanced maintainability and scalability."
    },
    {
      "type": "class",
      "name": "ProductImageCreate",
      "content": "class ProductImageCreate:\n    # Inherits from: ProductImageBase\n    # Purpose: Product image creation schema",
      "metadata": {
        "file_path": "app/schemas/product.py",
        "chunk_type": "class",
        "name": "ProductImageCreate",
        "purpose": "Product image creation schema",
        "dependencies": [],
        "access_level": "public",
        "class_name": "ProductImageCreate",
        "methods": [],
        "attributes": [],
        "base_classes": [
          "ProductImageBase"
        ],
        "decorators": []
      },
      "description": "**Class Description: ProductImageCreate**\n\nThe `ProductImageCreate` class serves as a schema for creating product images within an e-commerce or inventory management system. By inheriting from `ProductImageBase`, it establishes a structured format for product image data, ensuring consistency and validation during the image creation process. This class addresses the need for a standardized approach to manage product visuals, which is crucial for enhancing user experience and improving product presentation.\n\nDevelopers would utilize the `ProductImageCreate` class when implementing features related to uploading or managing product images, particularly in applications that require adherence to specific data formats or validation rules. Its integration into the system streamlines the process of adding new product images, thereby facilitating better inventory management and improving overall product visibility in online catalogs."
    },
    {
      "type": "class",
      "name": "ProductImageResponse",
      "content": "class ProductImageResponse:\n    # Inherits from: ProductImageBase\n    # Purpose: Product image response schema",
      "metadata": {
        "file_path": "app/schemas/product.py",
        "chunk_type": "class",
        "name": "ProductImageResponse",
        "purpose": "Product image response schema",
        "dependencies": [],
        "access_level": "public",
        "class_name": "ProductImageResponse",
        "methods": [],
        "attributes": [],
        "base_classes": [
          "ProductImageBase"
        ],
        "decorators": []
      },
      "description": "**Description of ProductImageResponse Class**\n\nThe `ProductImageResponse` class is a schema designed to encapsulate the response structure for product images within an application. It inherits from the `ProductImageBase` class, ensuring that it retains foundational attributes and behaviors related to product images. This class addresses the need for a standardized format for returning product image data, which is crucial for maintaining consistency in API responses.\n\nDevelopers would utilize the `ProductImageResponse` class when implementing features that require the retrieval and display of product images, such as e-commerce platforms or inventory management systems. By providing a clear and structured response format, it simplifies the integration of product images into user interfaces and enhances the overall user experience.\n\nIn the broader system architecture, this class serves as a key component in the data layer, facilitating communication between the backend services and frontend applications, thereby streamlining the process of handling product-related media."
    },
    {
      "type": "class",
      "name": "ProductBase",
      "content": "class ProductBase:\n    # Inherits from: BaseModel\n    # Purpose: Base product schema",
      "metadata": {
        "file_path": "app/schemas/product.py",
        "chunk_type": "class",
        "name": "ProductBase",
        "purpose": "Base product schema",
        "dependencies": [],
        "access_level": "public",
        "class_name": "ProductBase",
        "methods": [],
        "attributes": [],
        "base_classes": [
          "BaseModel"
        ],
        "decorators": []
      },
      "description": "**Description of ProductBase Class:**\n\nThe `ProductBase` class serves as a foundational schema for product entities within a software system, inheriting from `BaseModel`. It provides a standardized structure for defining product attributes, ensuring consistency across different product implementations. This class addresses the need for a common baseline in product data management, facilitating easier data handling and integration within larger applications.\n\nDevelopers would utilize `ProductBase` when creating various product types, allowing them to extend its functionality without redefining core attributes. It fits into the system as a critical component for product-related operations, streamlining the development process and enhancing maintainability by promoting code reuse."
    },
    {
      "type": "class",
      "name": "ProductCreate",
      "content": "class ProductCreate:\n    # Inherits from: ProductBase\n    # Purpose: Product creation schema\n\n    def validate_price(self, ...):\n        # Method implementation\n\n    def validate_stock(self, ...):\n        # Method implementation",
      "metadata": {
        "file_path": "app/schemas/product.py",
        "chunk_type": "class",
        "name": "ProductCreate",
        "purpose": "Product creation schema",
        "dependencies": [],
        "access_level": "public",
        "class_name": "ProductCreate",
        "methods": [
          "validate_price",
          "validate_stock"
        ],
        "attributes": [],
        "base_classes": [
          "ProductBase"
        ],
        "decorators": []
      },
      "description": "**Description:**\n\nThe `ProductCreate` class is a schema designed for creating new product entries within an application. It inherits from the `ProductBase` class, ensuring that it retains foundational product attributes while adding specific validation methods. This class addresses the need for structured product creation by providing two key methods: `validate_price` and `validate_stock`, which ensure that the price and stock levels of a product meet defined criteria before submission. Developers would utilize this class when implementing product management features in e-commerce platforms or inventory systems, ensuring data integrity and consistency during the product creation process. By integrating this class into the system, it enhances the overall architecture by promoting reusable validation logic and maintaining a clear separation of concerns in product handling."
    },
    {
      "type": "class",
      "name": "ProductUpdate",
      "content": "class ProductUpdate:\n    # Inherits from: BaseModel\n    # Purpose: Product update schema",
      "metadata": {
        "file_path": "app/schemas/product.py",
        "chunk_type": "class",
        "name": "ProductUpdate",
        "purpose": "Product update schema",
        "dependencies": [],
        "access_level": "public",
        "class_name": "ProductUpdate",
        "methods": [],
        "attributes": [],
        "base_classes": [
          "BaseModel"
        ],
        "decorators": []
      },
      "description": "**Description of ProductUpdate Class:**\n\nThe `ProductUpdate` class is a schema representation for updating product information within an application. It inherits from `BaseModel`, ensuring it follows a structured format for data validation and management. This class addresses the need for a standardized way to handle product updates, streamlining the process of modifying product attributes such as price, description, or availability.\n\nDevelopers would utilize the `ProductUpdate` class when implementing features that require modifying existing product data, ensuring consistency and reliability in data handling. It fits into the system as part of a broader model architecture, likely serving in conjunction with other classes that manage product creation, retrieval, and deletion, thereby enhancing the overall product management workflow."
    },
    {
      "type": "class",
      "name": "ProductResponse",
      "content": "class ProductResponse:\n    # Inherits from: ProductBase\n    # Purpose: Product response schema",
      "metadata": {
        "file_path": "app/schemas/product.py",
        "chunk_type": "class",
        "name": "ProductResponse",
        "purpose": "Product response schema",
        "dependencies": [],
        "access_level": "public",
        "class_name": "ProductResponse",
        "methods": [],
        "attributes": [],
        "base_classes": [
          "ProductBase"
        ],
        "decorators": []
      },
      "description": "**Description of ProductResponse Class:**\n\nThe `ProductResponse` class serves as a schema for representing product responses in an application, inheriting from the `ProductBase` class. It provides a structured format for product-related data, ensuring consistency and clarity when handling product information. This class addresses the need for a standardized response format, simplifying data management and communication between different system components, such as APIs and databases. Developers would utilize this class when implementing features that involve product retrieval or display, ensuring that product data is accurately represented and easily accessible. By fitting into the overall system architecture, it enhances data integrity and facilitates seamless integration with other modules that interact with product data."
    },
    {
      "type": "class",
      "name": "ProductListResponse",
      "content": "class ProductListResponse:\n    # Inherits from: BaseModel\n    # Purpose: Product list response schema",
      "metadata": {
        "file_path": "app/schemas/product.py",
        "chunk_type": "class",
        "name": "ProductListResponse",
        "purpose": "Product list response schema",
        "dependencies": [],
        "access_level": "public",
        "class_name": "ProductListResponse",
        "methods": [],
        "attributes": [],
        "base_classes": [
          "BaseModel"
        ],
        "decorators": []
      },
      "description": "**Description:**\n\nThe `ProductListResponse` class is a schema representation for the response structure of a product list in a system, inheriting from the `BaseModel`. It serves to standardize the format of product data returned from an API or service, ensuring consistency and clarity in data handling. This class addresses the need for a structured response when retrieving multiple product entries, simplifying the integration process for developers working with product data. Developers would use this class when implementing features that involve displaying or processing lists of products, such as e-commerce platforms or inventory management systems. By providing a clear schema, it enhances data validation and serialization, fitting seamlessly into the overall architecture of applications that require robust product data management."
    },
    {
      "type": "class",
      "name": "Config",
      "content": "class Config:\n    # Purpose: No description available",
      "metadata": {
        "file_path": "app/schemas/product.py",
        "chunk_type": "class",
        "name": "Config",
        "purpose": "Class Config",
        "dependencies": [],
        "access_level": "public",
        "class_name": "Config",
        "methods": [],
        "attributes": [],
        "base_classes": [],
        "decorators": []
      },
      "description": "**Description of the Config Class:**\n\nThe `Config` class serves as a placeholder for configuration settings within a Python application. Although it currently contains no methods or attributes, it is designed to encapsulate configuration-related data, allowing for future expansion and organization of application settings. Developers would use this class when they need a structured way to manage configuration parameters, ensuring that settings can be easily modified and accessed throughout the system. As part of a larger architecture, the `Config` class can facilitate the separation of configuration logic from business logic, enhancing maintainability and clarity in code management."
    },
    {
      "type": "class",
      "name": "Config",
      "content": "class Config:\n    # Purpose: No description available",
      "metadata": {
        "file_path": "app/schemas/product.py",
        "chunk_type": "class",
        "name": "Config",
        "purpose": "Class Config",
        "dependencies": [],
        "access_level": "public",
        "class_name": "Config",
        "methods": [],
        "attributes": [],
        "base_classes": [],
        "decorators": []
      },
      "description": "**Description of the Config Class**\n\nThe `Config` class serves as a placeholder for configuration settings within a Python application. Although it currently contains no methods or attributes, it is designed to encapsulate configuration-related data, providing a structured way to manage application settings. Developers would use this class when they need to define and organize configuration parameters, ensuring maintainability and clarity in their codebase. As part of a larger system, the `Config` class can be extended in the future to include methods for loading, validating, and applying configuration settings, thus addressing issues related to configuration management and enhancing the overall architecture of the application."
    },
    {
      "type": "function",
      "name": "validate_price",
      "content": "    def validate_price(cls, v):\n        if v <= 0:\n            raise ValueError('Price must be greater than 0')\n        return v",
      "metadata": {
        "file_path": "app/schemas/product.py",
        "chunk_type": "function",
        "name": "validate_price",
        "purpose": "Function validate_price",
        "dependencies": [],
        "access_level": "public",
        "function_name": "validate_price",
        "parameters": [
          "cls",
          "v"
        ],
        "return_type": "",
        "decorators": [
          "validator('price')"
        ],
        "is_async": false
      },
      "description": "**Description of `validate_price` Function:**\n\nThe `validate_price` function is a class method designed to ensure that a given price value is valid. It accepts two parameters: `cls`, which refers to the class itself (used in class methods), and `v`, the price value to be validated. The function checks if the price `v` is less than or equal to zero; if so, it raises a `ValueError` with the message \"Price must be greater than 0\". If the price is valid (greater than zero), it returns the price value `v`.\n\nDevelopers would use this function in scenarios where price validation is critical, such as in e-commerce applications or financial systems, to prevent invalid data entry. It effectively solves the problem of ensuring that only positive price values are accepted, thereby maintaining data integrity and preventing potential errors in calculations or transactions."
    },
    {
      "type": "function",
      "name": "validate_stock",
      "content": "    def validate_stock(cls, v):\n        if v < 0:\n            raise ValueError('Stock quantity cannot be negative')\n        return v",
      "metadata": {
        "file_path": "app/schemas/product.py",
        "chunk_type": "function",
        "name": "validate_stock",
        "purpose": "Function validate_stock",
        "dependencies": [],
        "access_level": "public",
        "function_name": "validate_stock",
        "parameters": [
          "cls",
          "v"
        ],
        "return_type": "",
        "decorators": [
          "validator('stock_quantity')"
        ],
        "is_async": false
      },
      "description": "**Function Description: validate_stock**\n\nThe `validate_stock` function is designed to ensure that a given stock quantity is valid. It takes two parameters: `cls`, which is typically a reference to the class (though not utilized in this function), and `v`, which represents the stock quantity to be validated. The function checks if `v` is less than zero and raises a `ValueError` with a descriptive message if this condition is met. If the stock quantity is valid (i.e., zero or positive), the function returns the value of `v`.\n\nDevelopers would use this function in scenarios where stock management is critical, such as inventory systems or e-commerce applications, to prevent negative stock levels that could lead to inaccurate inventory records. By enforcing this validation, the function helps maintain data integrity and prevents potential errors in stock-related calculations or transactions."
    },
    {
      "type": "imports",
      "name": "module_imports",
      "content": "Module Dependencies:\n\nStandard Library: typing\n  - Optional\n\nThird Party: pydantic\n  - BaseModel, validator",
      "metadata": {
        "file_path": "app/schemas/category.py",
        "chunk_type": "imports",
        "name": "module_imports",
        "purpose": "Module dependencies and imports",
        "dependencies": [],
        "access_level": "public",
        "imports": [
          {
            "module": "typing",
            "type": "standard",
            "items": [
              "Optional"
            ]
          },
          {
            "module": "pydantic",
            "type": "third_party",
            "items": [
              "BaseModel",
              "validator"
            ]
          }
        ]
      },
      "description": "The `module_imports` Python module manages its dependencies and imports essential libraries for type handling and data validation. It relies on the standard library's `typing` module, specifically utilizing the `Optional` type for flexible type annotations. Additionally, it integrates the third-party library `pydantic`, leveraging its `BaseModel` for data modeling and `validator` for input validation. This module serves as a foundational component within a larger system, ensuring robust type safety and data integrity through its structured dependencies and external libraries."
    },
    {
      "type": "class",
      "name": "CategoryBase",
      "content": "class CategoryBase:\n    # Inherits from: BaseModel\n    # Purpose: Base category schema",
      "metadata": {
        "file_path": "app/schemas/category.py",
        "chunk_type": "class",
        "name": "CategoryBase",
        "purpose": "Base category schema",
        "dependencies": [],
        "access_level": "public",
        "class_name": "CategoryBase",
        "methods": [],
        "attributes": [],
        "base_classes": [
          "BaseModel"
        ],
        "decorators": []
      },
      "description": "**Description of CategoryBase Class:**\n\nThe `CategoryBase` class serves as a foundational schema for categorizing entities within a system, inheriting from `BaseModel`. It provides a structured representation of categories, enabling developers to define and manage category-related data consistently. This class addresses the need for a standardized base that can be extended for specific category implementations, thereby promoting code reusability and maintainability. Developers would utilize `CategoryBase` when creating category-related features in applications, ensuring a uniform approach to category management. Its role in the system is to establish a common framework for all category types, facilitating easier integration and interaction with other components that rely on category data."
    },
    {
      "type": "class",
      "name": "CategoryCreate",
      "content": "class CategoryCreate:\n    # Inherits from: CategoryBase\n    # Purpose: Category creation schema\n\n    def validate_name(self, ...):\n        # Method implementation\n\n    def validate_slug(self, ...):\n        # Method implementation",
      "metadata": {
        "file_path": "app/schemas/category.py",
        "chunk_type": "class",
        "name": "CategoryCreate",
        "purpose": "Category creation schema",
        "dependencies": [],
        "access_level": "public",
        "class_name": "CategoryCreate",
        "methods": [
          "validate_name",
          "validate_slug"
        ],
        "attributes": [],
        "base_classes": [
          "CategoryBase"
        ],
        "decorators": []
      },
      "description": "**Description of the CategoryCreate Class:**\n\nThe `CategoryCreate` class serves as a schema for creating new categories within an application. It inherits from `CategoryBase`, ensuring consistent structure and behavior across category-related functionalities. This class addresses the need for validating category names and slugs, which are essential for maintaining data integrity and preventing conflicts in category identifiers.\n\nDevelopers would utilize the `CategoryCreate` class when implementing features that require the creation of new categories, such as in content management systems or e-commerce platforms. Its validation methods ensure that the input data adheres to predefined rules, thus minimizing errors and enhancing user experience.\n\nBy integrating into the broader system, `CategoryCreate` plays a critical role in the category management workflow, facilitating the seamless addition of new categories while enforcing validation standards."
    },
    {
      "type": "class",
      "name": "CategoryUpdate",
      "content": "class CategoryUpdate:\n    # Inherits from: BaseModel\n    # Purpose: Category update schema",
      "metadata": {
        "file_path": "app/schemas/category.py",
        "chunk_type": "class",
        "name": "CategoryUpdate",
        "purpose": "Category update schema",
        "dependencies": [],
        "access_level": "public",
        "class_name": "CategoryUpdate",
        "methods": [],
        "attributes": [],
        "base_classes": [
          "BaseModel"
        ],
        "decorators": []
      },
      "description": "**Description of the CategoryUpdate Class:**\n\nThe `CategoryUpdate` class is a schema designed for managing updates to category data within an application. It inherits from `BaseModel`, indicating that it follows a structured format for data validation and serialization. This class serves to streamline the process of modifying existing category attributes, ensuring that updates are consistent and adhere to predefined rules.\n\nDevelopers would utilize the `CategoryUpdate` class when implementing features that require the modification of category information, such as in content management systems or e-commerce platforms. By providing a clear schema for updates, it helps prevent errors and enhances data integrity.\n\nIn the broader system architecture, this class plays a crucial role in the data layer, facilitating communication between the application logic and the database. It ensures that category updates are handled efficiently and effectively, contributing to a robust and maintainable codebase."
    },
    {
      "type": "class",
      "name": "CategoryResponse",
      "content": "class CategoryResponse:\n    # Inherits from: CategoryBase\n    # Purpose: Category response schema",
      "metadata": {
        "file_path": "app/schemas/category.py",
        "chunk_type": "class",
        "name": "CategoryResponse",
        "purpose": "Category response schema",
        "dependencies": [],
        "access_level": "public",
        "class_name": "CategoryResponse",
        "methods": [],
        "attributes": [],
        "base_classes": [
          "CategoryBase"
        ],
        "decorators": []
      },
      "description": "**Description of CategoryResponse Class**\n\nThe `CategoryResponse` class serves as a schema for representing category responses in a system that likely deals with categorization or classification tasks. By inheriting from `CategoryBase`, it establishes a foundational structure for category-related data, ensuring consistency and reusability across the application. \n\nThis class addresses the need for a standardized response format, simplifying the handling of category data in APIs or data processing workflows. Developers would utilize `CategoryResponse` when implementing features that require returning category information, such as in e-commerce platforms, content management systems, or any application that organizes items into categories.\n\nIn the broader system architecture, `CategoryResponse` fits into the data layer, acting as a model that interfaces with other components, such as controllers or services, to facilitate data exchange and maintain data integrity. Its presence enhances code clarity and maintainability by providing a clear structure for category-related responses."
    },
    {
      "type": "class",
      "name": "Config",
      "content": "class Config:\n    # Purpose: No description available",
      "metadata": {
        "file_path": "app/schemas/category.py",
        "chunk_type": "class",
        "name": "Config",
        "purpose": "Class Config",
        "dependencies": [],
        "access_level": "public",
        "class_name": "Config",
        "methods": [],
        "attributes": [],
        "base_classes": [],
        "decorators": []
      },
      "description": "**Description of the Config Class:**\n\nThe `Config` class serves as a placeholder or marker within a codebase, indicating a configuration management structure. Although it currently contains no methods or attributes, it is designed to encapsulate configuration settings or parameters that may be utilized throughout an application. Developers would use this class when they need a centralized location to manage application settings, enhancing maintainability and readability. It fits into the system as a foundational component for future enhancements, allowing for easy expansion to include configuration options, thereby addressing the need for organized and scalable configuration management."
    },
    {
      "type": "function",
      "name": "validate_name",
      "content": "    def validate_name(cls, v):\n        if len(v) < 2:\n            raise ValueError('Category name must be at least 2 characters long')\n        return v",
      "metadata": {
        "file_path": "app/schemas/category.py",
        "chunk_type": "function",
        "name": "validate_name",
        "purpose": "Function validate_name",
        "dependencies": [],
        "access_level": "public",
        "function_name": "validate_name",
        "parameters": [
          "cls",
          "v"
        ],
        "return_type": "",
        "decorators": [
          "validator('name')"
        ],
        "is_async": false
      },
      "description": "**Function Description: validate_name**\n\nThe `validate_name` function is designed to ensure that a given category name meets a minimum length requirement. It takes two parameters: `cls`, which typically represents the class context (though it is not utilized within the function), and `v`, which is the category name string to be validated. \n\nThe function checks if the length of `v` is less than 2 characters. If it is, a `ValueError` is raised with a message indicating that the category name must be at least 2 characters long. If the validation passes, the function returns the original string `v`.\n\nDevelopers would use this function when creating or managing categories in applications, ensuring that all category names adhere to a specified minimum length for consistency and usability. This function helps prevent errors related to overly short category names, enhancing data integrity and user experience."
    },
    {
      "type": "function",
      "name": "validate_slug",
      "content": "    def validate_slug(cls, v):\n        if not v.replace('-', '').replace('_', '').isalnum():\n            raise ValueError('Slug must contain only alphanumeric characters, hyphens, and underscores')\n        return v",
      "metadata": {
        "file_path": "app/schemas/category.py",
        "chunk_type": "function",
        "name": "validate_slug",
        "purpose": "Function validate_slug",
        "dependencies": [],
        "access_level": "public",
        "function_name": "validate_slug",
        "parameters": [
          "cls",
          "v"
        ],
        "return_type": "",
        "decorators": [
          "validator('slug')"
        ],
        "is_async": false
      },
      "description": "**Function Description: validate_slug**\n\nThe `validate_slug` function is designed to validate a string input, ensuring that it conforms to the criteria for a valid slug. It accepts two parameters: `cls`, which is typically a reference to the class (used in class methods), and `v`, the string value to be validated. \n\nThe function checks if the input string `v` contains only alphanumeric characters, hyphens, and underscores by removing hyphens and underscores and verifying if the remaining characters are alphanumeric. If the validation fails, it raises a `ValueError` with a descriptive message. If the input is valid, the function returns the original string `v`.\n\nDevelopers would use this function when creating slugs for URLs, ensuring that they are SEO-friendly and comply with web standards. It solves the problem of invalid characters in slugs, which can lead to errors in URL generation or routing."
    },
    {
      "type": "imports",
      "name": "module_imports",
      "content": "Module Dependencies:\n\nThird Party: redis\n  - redis\n\nStandard Library: json\n  - json\n\nStandard Library: typing\n  - Dict, Any, Optional\n\nLocal: app.core.config\n  - settings",
      "metadata": {
        "file_path": "app/services/notification.py",
        "chunk_type": "imports",
        "name": "module_imports",
        "purpose": "Module dependencies and imports",
        "dependencies": [],
        "access_level": "public",
        "imports": [
          {
            "module": "redis",
            "type": "third_party",
            "items": [
              "redis"
            ]
          },
          {
            "module": "json",
            "type": "standard",
            "items": [
              "json"
            ]
          },
          {
            "module": "typing",
            "type": "standard",
            "items": [
              "Dict",
              "Any",
              "Optional"
            ]
          },
          {
            "module": "app.core.config",
            "type": "local",
            "items": [
              "settings"
            ]
          }
        ]
      },
      "description": "The `module_imports` Python module manages dependencies essential for its functionality. It utilizes the third-party library `redis` for interacting with Redis databases, enabling efficient data storage and retrieval. Additionally, it incorporates standard libraries: `json` for handling JSON data serialization and deserialization, and `typing` for type hinting with `Dict`, `Any`, and `Optional`, enhancing code clarity and type safety. The module also imports local configuration settings from `app.core.config`, allowing for customizable application behavior. Overall, this module serves as a foundational component within the system, facilitating data management and configuration through its diverse set of dependencies."
    },
    {
      "type": "class",
      "name": "NotificationService",
      "content": "class NotificationService:\n    # Purpose: Notification service for real-time updates\n\n    def __init__(self, ...):\n        # Method implementation\n\n    def publish_notification(self, ...):\n        # Method implementation\n\n    def notify_order_update(self, ...):\n        # Method implementation\n\n    def notify_stock_update(self, ...):\n        # Method implementation\n\n    def notify_system_alert(self, ...):\n        # Method implementation",
      "metadata": {
        "file_path": "app/services/notification.py",
        "chunk_type": "class",
        "name": "NotificationService",
        "purpose": "Notification service for real-time updates",
        "dependencies": [],
        "access_level": "public",
        "class_name": "NotificationService",
        "methods": [
          "__init__",
          "publish_notification",
          "notify_order_update",
          "notify_stock_update",
          "notify_system_alert"
        ],
        "attributes": [],
        "base_classes": [],
        "decorators": []
      },
      "description": "**Description of NotificationService Class**\n\nThe `NotificationService` class is designed to facilitate real-time updates within an application by providing a structured way to publish and manage notifications. This class addresses the need for timely communication of important events, such as order updates, stock changes, and system alerts, ensuring that users and systems are promptly informed of critical changes.\n\nDevelopers would utilize this class in scenarios where immediate feedback or updates are essential, such as e-commerce platforms, inventory management systems, or any application requiring user engagement through notifications. By integrating the `NotificationService`, developers can enhance user experience and operational efficiency by automating the dissemination of information.\n\nThis class fits into the overall system architecture as a dedicated service layer that interacts with various components, enabling seamless communication and event handling across the application. Its methods, including `publish_notification`, `notify_order_update`, `notify_stock_update`, and `notify_system_alert`, provide specific functionalities to cater to different notification needs, making it a versatile tool for real-time communication"
    },
    {
      "type": "function",
      "name": "__init__",
      "content": "    def __init__(self):\n        self.redis_client = redis.from_url(settings.REDIS_URL)",
      "metadata": {
        "file_path": "app/services/notification.py",
        "chunk_type": "function",
        "name": "__init__",
        "purpose": "Function __init__",
        "dependencies": [],
        "access_level": "public",
        "function_name": "__init__",
        "parameters": [
          "self"
        ],
        "return_type": "",
        "decorators": [],
        "is_async": false
      },
      "description": "**Description of the `__init__` Function:**\n\nThe `__init__` function is a constructor method in Python that initializes an instance of a class. It expects a single parameter, `self`, which refers to the instance being created. Within this function, a Redis client is instantiated using the URL specified in the application settings (`settings.REDIS_URL`). This setup allows the class to interact with a Redis database for data storage and retrieval.\n\nThe function does not return any value; instead, it initializes the `redis_client` attribute of the class instance. Developers would use this function when they need to establish a connection to a Redis database upon creating an object of the class, facilitating efficient data management and caching solutions. It solves the problem of setting up a Redis client connection seamlessly, ensuring that the class has the necessary tools to perform database operations right from the moment of instantiation."
    },
    {
      "type": "function",
      "name": "publish_notification",
      "content": "    def publish_notification(\n        self,\n        channel: str,\n        message: Dict[str, Any]\n    ) -> bool:\n        \"\"\"Publish notification to Redis channel\"\"\"\n        try:\n            self.redis_client.publish(channel, json.dumps(message))\n            return True\n        except Exception as e:\n            print(f\"Failed to publish notification: {e}\")\n            return False",
      "metadata": {
        "file_path": "app/services/notification.py",
        "chunk_type": "function",
        "name": "publish_notification",
        "purpose": "Publish notification to Redis channel",
        "dependencies": [],
        "access_level": "public",
        "function_name": "publish_notification",
        "parameters": [
          "self",
          "channel: str",
          "message: Dict[str, Any]"
        ],
        "return_type": "bool",
        "decorators": [],
        "is_async": false
      },
      "description": "**Function Description: `publish_notification`**\n\nThe `publish_notification` function is designed to send notifications to a specified Redis channel. It takes two parameters: `channel`, a string representing the name of the Redis channel, and `message`, a dictionary containing the notification data. The function attempts to publish the message in JSON format to the given channel using a Redis client. \n\nIf the publication is successful, it returns `True`; if an error occurs during the process, it catches the exception, logs an error message, and returns `False`. \n\nDevelopers would use this function in scenarios where real-time notifications or messages need to be dispatched across distributed systems or services, such as in event-driven architectures or microservices. It addresses the challenge of efficiently communicating updates or alerts to multiple subscribers in a scalable manner."
    },
    {
      "type": "function",
      "name": "notify_order_update",
      "content": "    def notify_order_update(self, user_id: int, order_id: int, status: str) -> bool:\n        \"\"\"Notify user about order status update\"\"\"\n        message = {\n            \"type\": \"order_update\",\n            \"user_id\": user_id,\n            \"order_id\": order_id,\n            \"status\": status,\n            \"timestamp\": str(datetime.utcnow())\n        }\n        return self.publish_notification(f\"user:{user_id}:notifications\", message)",
      "metadata": {
        "file_path": "app/services/notification.py",
        "chunk_type": "function",
        "name": "notify_order_update",
        "purpose": "Notify user about order status update",
        "dependencies": [],
        "access_level": "public",
        "function_name": "notify_order_update",
        "parameters": [
          "self",
          "user_id: int",
          "order_id: int",
          "status: str"
        ],
        "return_type": "bool",
        "decorators": [],
        "is_async": false
      },
      "description": "The `notify_order_update` function is designed to inform users about updates to their order status. It takes four parameters: `user_id` (an integer representing the user's ID), `order_id` (an integer for the specific order), and `status` (a string indicating the new status of the order). The function constructs a notification message that includes the type of notification, user ID, order ID, status, and a timestamp of the update. It then publishes this notification to a user-specific notification channel.\n\nThe function returns a boolean value indicating the success of the notification publishing process. Developers would use this function in e-commerce or order management systems to keep users informed about their order statuses, thereby enhancing user experience and engagement. It addresses the problem of timely communication regarding order updates, ensuring users are aware of changes without needing to check manually."
    },
    {
      "type": "function",
      "name": "notify_stock_update",
      "content": "    def notify_stock_update(self, product_id: int, new_stock: int) -> bool:\n        \"\"\"Notify about product stock update\"\"\"\n        message = {\n            \"type\": \"stock_update\",\n            \"product_id\": product_id,\n            \"new_stock\": new_stock,\n            \"timestamp\": str(datetime.utcnow())\n        }\n        return self.publish_notification(\"product:stock_updates\", message)",
      "metadata": {
        "file_path": "app/services/notification.py",
        "chunk_type": "function",
        "name": "notify_stock_update",
        "purpose": "Notify about product stock update",
        "dependencies": [],
        "access_level": "public",
        "function_name": "notify_stock_update",
        "parameters": [
          "self",
          "product_id: int",
          "new_stock: int"
        ],
        "return_type": "bool",
        "decorators": [],
        "is_async": false
      },
      "description": "The `notify_stock_update` function is designed to send notifications regarding updates to product stock levels. It takes three parameters: `self` (the instance of the class), `product_id` (an integer representing the unique identifier of the product), and `new_stock` (an integer indicating the updated stock quantity). The function constructs a message dictionary containing the notification type, product ID, new stock amount, and a timestamp of the update. It then calls the `publish_notification` method to send this message to a specified topic, returning a boolean value indicating the success of the notification process. Developers would use this function in inventory management systems or e-commerce platforms to inform relevant stakeholders about stock changes, thereby addressing issues related to stock visibility and timely updates for inventory tracking."
    },
    {
      "type": "function",
      "name": "notify_system_alert",
      "content": "    def notify_system_alert(self, alert_type: str, message: str) -> bool:\n        \"\"\"Notify system administrators about alerts\"\"\"\n        alert_message = {\n            \"type\": \"system_alert\",\n            \"alert_type\": alert_type,\n            \"message\": message,\n            \"timestamp\": str(datetime.utcnow())\n        }\n        return self.publish_notification(\"system:alerts\", alert_message)",
      "metadata": {
        "file_path": "app/services/notification.py",
        "chunk_type": "function",
        "name": "notify_system_alert",
        "purpose": "Notify system administrators about alerts",
        "dependencies": [],
        "access_level": "public",
        "function_name": "notify_system_alert",
        "parameters": [
          "self",
          "alert_type: str",
          "message: str"
        ],
        "return_type": "bool",
        "decorators": [],
        "is_async": false
      },
      "description": "The `notify_system_alert` function is designed to inform system administrators about specific alerts within a system. It takes three parameters: `self`, `alert_type` (a string indicating the type of alert), and `message` (a string containing the alert details). The function constructs an alert message dictionary that includes the alert type, message, and a timestamp of when the alert was generated. It then calls the `publish_notification` method to send this alert to a designated notification channel, returning a boolean value that indicates the success of the notification process.\n\nDevelopers would use this function in scenarios where timely communication of system alerts is critical, such as in monitoring applications or incident response systems. It addresses the need for efficient alert management by automating the notification process, ensuring that system administrators are promptly informed about issues that require their attention."
    },
    {
      "type": "imports",
      "name": "module_imports",
      "content": "Module Dependencies:\n\nThird Party: smtplib\n  - smtplib\n\nThird Party: email.mime.text\n  - MIMEText\n\nThird Party: email.mime.multipart\n  - MIMEMultipart\n\nStandard Library: typing\n  - Optional, List\n\nLocal: app.core.config\n  - settings",
      "metadata": {
        "file_path": "app/services/email.py",
        "chunk_type": "imports",
        "name": "module_imports",
        "purpose": "Module dependencies and imports",
        "dependencies": [],
        "access_level": "public",
        "imports": [
          {
            "module": "smtplib",
            "type": "third_party",
            "items": [
              "smtplib"
            ]
          },
          {
            "module": "email.mime.text",
            "type": "third_party",
            "items": [
              "MIMEText"
            ]
          },
          {
            "module": "email.mime.multipart",
            "type": "third_party",
            "items": [
              "MIMEMultipart"
            ]
          },
          {
            "module": "typing",
            "type": "standard",
            "items": [
              "Optional",
              "List"
            ]
          },
          {
            "module": "app.core.config",
            "type": "local",
            "items": [
              "settings"
            ]
          }
        ]
      },
      "description": "The `module_imports` Python module manages dependencies and imports essential for its functionality. It utilizes third-party libraries such as `smtplib` for sending emails and `email.mime.text` and `email.mime.multipart` for constructing email messages with text and multipart formats, respectively. Additionally, it incorporates the standard library's `typing` module, specifically `Optional` and `List`, to enhance type hinting and improve code readability. The module also imports local configuration settings from `app.core.config`, which likely contains application-specific configurations. Overall, this module serves as a foundational component for email handling within the system, leveraging external libraries for email functionality and ensuring type safety through standard library features."
    },
    {
      "type": "class",
      "name": "EmailService",
      "content": "class EmailService:\n    # Purpose: Email service for sending notifications\n\n    def __init__(self, ...):\n        # Method implementation\n\n    def send_email(self, ...):\n        # Method implementation\n\n    def send_bulk_email(self, ...):\n        # Method implementation\n\n    def send_order_confirmation(self, ...):\n        # Method implementation\n\n    def send_password_reset(self, ...):\n        # Method implementation",
      "metadata": {
        "file_path": "app/services/email.py",
        "chunk_type": "class",
        "name": "EmailService",
        "purpose": "Email service for sending notifications",
        "dependencies": [],
        "access_level": "public",
        "class_name": "EmailService",
        "methods": [
          "__init__",
          "send_email",
          "send_bulk_email",
          "send_order_confirmation",
          "send_password_reset"
        ],
        "attributes": [],
        "base_classes": [],
        "decorators": []
      },
      "description": "**Description:**\n\nThe `EmailService` class is designed to facilitate the sending of email notifications within an application. It provides a structured approach to managing various email-related tasks, including sending individual emails, bulk emails, order confirmations, and password reset notifications. This class addresses the need for efficient communication with users by automating email delivery, thereby enhancing user engagement and improving operational efficiency. Developers would use this class in scenarios where automated email notifications are required, such as e-commerce platforms, user account management systems, or any application needing reliable email communication. By integrating the `EmailService` class into the system, developers can streamline the notification process, ensuring timely and consistent communication with users while reducing the complexity of email handling in the codebase."
    },
    {
      "type": "function",
      "name": "__init__",
      "content": "    def __init__(self):\n        self.smtp_host = settings.SMTP_HOST\n        self.smtp_port = settings.SMTP_PORT\n        self.smtp_user = settings.SMTP_USER\n        self.smtp_password = settings.SMTP_PASSWORD",
      "metadata": {
        "file_path": "app/services/email.py",
        "chunk_type": "function",
        "name": "__init__",
        "purpose": "Function __init__",
        "dependencies": [],
        "access_level": "public",
        "function_name": "__init__",
        "parameters": [
          "self"
        ],
        "return_type": "",
        "decorators": [],
        "is_async": false
      },
      "description": "**Description of `__init__` Function in Python**\n\nThe `__init__` function is a constructor method in a Python class that initializes an instance of the class. It sets up essential attributes for SMTP (Simple Mail Transfer Protocol) configuration by retrieving values from a settings module. The function expects a single input parameter, `self`, which refers to the instance being created. It does not return any value, as its primary purpose is to initialize instance variables.\n\nDevelopers would use this function when creating an object that requires SMTP settings for email functionality, ensuring that the necessary parameters such as `smtp_host`, `smtp_port`, `smtp_user`, and `smtp_password` are readily available for sending emails. This function solves the problem of managing email configurations by centralizing the setup process, making it easier to maintain and modify SMTP settings in one place."
    },
    {
      "type": "function",
      "name": "send_email",
      "content": "    def send_email(\n        self,\n        to_email: str,\n        subject: str,\n        body: str,\n        html_body: Optional[str] = None\n    ) -> bool:\n        \"\"\"Send email to single recipient\"\"\"\n        if not all([self.smtp_host, self.smtp_user, self.smtp_password]):\n            print(\"SMTP configuration not available\")\n            return False\n        \n        try:\n            msg = MIMEMultipart('alternative')\n            msg['From'] = self.smtp_user\n            msg['To'] = to_email\n            msg['Subject'] = subject\n            \n            # Add text part\n            text_part = MIMEText(body, 'plain')\n            msg.attach(text_part)\n            \n            # Add HTML part if provided\n            if html_body:\n                html_part = MIMEText(html_body, 'html')\n                msg.attach(html_part)\n            \n            # Send email\n            with smtplib.SMTP(self.smtp_host, self.smtp_port) as server:\n                server.starttls()\n                server.login(self.smtp_user, self.smtp_password)\n                server.send_message(msg)\n            \n            return True\n            \n        except Exception as e:\n            print(f\"Failed to send email: {e}\")\n            return False",
      "metadata": {
        "file_path": "app/services/email.py",
        "chunk_type": "function",
        "name": "send_email",
        "purpose": "Send email to single recipient",
        "dependencies": [],
        "access_level": "public",
        "function_name": "send_email",
        "parameters": [
          "self",
          "to_email: str",
          "subject: str",
          "body: str",
          "html_body: Optional[str]"
        ],
        "return_type": "bool",
        "decorators": [],
        "is_async": false
      },
      "description": "**Description of `send_email` Function:**\n\nThe `send_email` function is designed to send an email to a single recipient using SMTP configuration. It requires four parameters: `to_email` (a string representing the recipient's email address), `subject` (a string for the email subject), `body` (a string containing the plain text content of the email), and an optional `html_body` (a string for HTML content). \n\nThe function checks for the availability of SMTP configuration (host, user, and password) before proceeding. If the configuration is missing, it prints an error message and returns `False`. If the configuration is valid, it constructs a multipart email message, attaching both the plain text and optional HTML content. The function returns a boolean value indicating the success of the email sending process.\n\nDevelopers would use this function when they need to send emails programmatically, such as in notification systems, user communications, or automated alerts. It addresses issues related to email delivery by"
    },
    {
      "type": "function",
      "name": "send_bulk_email",
      "content": "    def send_bulk_email(\n        self,\n        to_emails: List[str],\n        subject: str,\n        body: str,\n        html_body: Optional[str] = None\n    ) -> int:\n        \"\"\"Send email to multiple recipients\"\"\"\n        success_count = 0\n        for email in to_emails:\n            if self.send_email(email, subject, body, html_body):\n                success_count += 1\n        return success_count",
      "metadata": {
        "file_path": "app/services/email.py",
        "chunk_type": "function",
        "name": "send_bulk_email",
        "purpose": "Send email to multiple recipients",
        "dependencies": [],
        "access_level": "public",
        "function_name": "send_bulk_email",
        "parameters": [
          "self",
          "to_emails: List[str]",
          "subject: str",
          "body: str",
          "html_body: Optional[str]"
        ],
        "return_type": "int",
        "decorators": [],
        "is_async": false
      },
      "description": "The `send_bulk_email` function is designed to facilitate the sending of emails to multiple recipients in a single operation. It accepts the following parameters: `to_emails`, a list of strings representing the email addresses of the recipients; `subject`, a string for the email subject; `body`, a string for the email content; and an optional `html_body`, which allows for HTML formatted content. The function iterates through the list of recipient emails, invoking the `send_email` method for each address. It returns an integer indicating the number of successfully sent emails. Developers would use this function when needing to communicate with a large group efficiently, such as in marketing campaigns or notifications, addressing the challenge of individual email sending and tracking success rates."
    },
    {
      "type": "function",
      "name": "send_order_confirmation",
      "content": "    def send_order_confirmation(self, user_email: str, order_number: str) -> bool:\n        \"\"\"Send order confirmation email\"\"\"\n        subject = f\"Order Confirmation - {order_number}\"\n        body = f\"\"\"\n        Thank you for your order!\n        \n        Order Number: {order_number}\n        \n        We have received your order and will process it shortly.\n        \n        Best regards,\n        E-commerce Team\n        \"\"\"\n        \n        html_body = f\"\"\"\n        <html>\n        <body>\n            <h2>Order Confirmation</h2>\n            <p>Thank you for your order!</p>\n            <p><strong>Order Number:</strong> {order_number}</p>\n            <p>We have received your order and will process it shortly.</p>\n            <p>Best regards,<br>E-commerce Team</p>\n        </body>\n        </html>\n        \"\"\"\n        \n        return self.send_email(user_email, subject, body, html_body)",
      "metadata": {
        "file_path": "app/services/email.py",
        "chunk_type": "function",
        "name": "send_order_confirmation",
        "purpose": "Send order confirmation email",
        "dependencies": [],
        "access_level": "public",
        "function_name": "send_order_confirmation",
        "parameters": [
          "self",
          "user_email: str",
          "order_number: str"
        ],
        "return_type": "bool",
        "decorators": [],
        "is_async": false
      },
      "description": "**Function Description: `send_order_confirmation`**\n\nThe `send_order_confirmation` function is designed to send an order confirmation email to a user after they have placed an order. It constructs both plain text and HTML formatted email content, incorporating the order number into the subject and body of the message.\n\n**Inputs:**\n- `self`: Refers to the instance of the class where this method is defined.\n- `user_email` (str): The email address of the user receiving the confirmation.\n- `order_number` (str): The unique identifier for the order being confirmed.\n\n**Returns:**\n- A boolean value (`bool`), indicating the success or failure of the email sending operation.\n\n**Usage Context:**\nDevelopers would use this function in e-commerce applications to automate the process of notifying customers about their order status, enhancing user experience and communication.\n\n**Problem Solved:**\nThis function addresses the need for timely and professional communication with customers by providing a structured way to confirm orders, thereby"
    },
    {
      "type": "function",
      "name": "send_password_reset",
      "content": "    def send_password_reset(self, user_email: str, reset_token: str) -> bool:\n        \"\"\"Send password reset email\"\"\"\n        subject = \"Password Reset Request\"\n        reset_url = f\"https://yourapp.com/reset-password?token={reset_token}\"\n        \n        body = f\"\"\"\n        Password Reset Request\n        \n        You requested a password reset for your account.\n        \n        Click the link below to reset your password:\n        {reset_url}\n        \n        This link will expire in 1 hour.\n        \n        If you didn't request this, please ignore this email.\n        \n        Best regards,\n        E-commerce Team\n        \"\"\"\n        \n        html_body = f\"\"\"\n        <html>\n        <body>\n            <h2>Password Reset Request</h2>\n            <p>You requested a password reset for your account.</p>\n            <p><a href=\"{reset_url}\">Click here to reset your password</a></p>\n            <p>This link will expire in 1 hour.</p>\n            <p>If you didn't request this, please ignore this email.</p>\n            <p>Best regards,<br>E-commerce Team</p>\n        </body>\n        </html>\n        \"\"\"\n        \n        return self.send_email(user_email, subject, body, html_body)",
      "metadata": {
        "file_path": "app/services/email.py",
        "chunk_type": "function",
        "name": "send_password_reset",
        "purpose": "Send password reset email",
        "dependencies": [],
        "access_level": "public",
        "function_name": "send_password_reset",
        "parameters": [
          "self",
          "user_email: str",
          "reset_token: str"
        ],
        "return_type": "bool",
        "decorators": [],
        "is_async": false
      },
      "description": "**Description of the `send_password_reset` Function:**\n\nThe `send_password_reset` function is designed to facilitate the process of sending a password reset email to users who have requested to reset their account credentials. It takes in two parameters: `user_email`, a string representing the email address of the user, and `reset_token`, a string that serves as a unique identifier for the password reset request.\n\nUpon execution, the function constructs an email with a subject line indicating a password reset request and generates a reset URL that includes the provided token. The email body contains instructions for the user, including a clickable link to reset their password, along with a note about the link's expiration time. The function returns a boolean value, indicating the success or failure of the email-sending operation.\n\nDevelopers would utilize this function in scenarios where user accounts require password recovery mechanisms, particularly in web applications or services that prioritize user security and accessibility. By automating the password reset email process, this function addresses the common"
    },
    {
      "type": "imports",
      "name": "module_imports",
      "content": "Module Dependencies:\n\nThird Party: fastapi\n  - APIRouter\n\nLocal: app.api.v1.endpoints\n  - auth, users, products, orders, categories",
      "metadata": {
        "file_path": "app/api/v1/router.py",
        "chunk_type": "imports",
        "name": "module_imports",
        "purpose": "Module dependencies and imports",
        "dependencies": [],
        "access_level": "public",
        "imports": [
          {
            "module": "fastapi",
            "type": "third_party",
            "items": [
              "APIRouter"
            ]
          },
          {
            "module": "app.api.v1.endpoints",
            "type": "local",
            "items": [
              "auth",
              "users",
              "products",
              "orders",
              "categories"
            ]
          }
        ]
      },
      "description": "The `module_imports` Python module manages dependencies and imports essential for the application's functionality. It relies on the third-party library **FastAPI**, specifically utilizing the **APIRouter** for building API endpoints. Additionally, it imports several local modules from `app.api.v1.endpoints`, including **auth**, **users**, **products**, **orders**, and **categories**, which collectively handle various aspects of user authentication, product management, order processing, and category organization. This module serves as a foundational component in the system, integrating external and internal functionalities to streamline API development and enhance modularity within the application."
    },
    {
      "type": "imports",
      "name": "module_imports",
      "content": "Module Dependencies:\n\nThird Party: fastapi\n  - APIRouter, Depends, HTTPException, status\n\nThird Party: fastapi.security\n  - OAuth2PasswordBearer, OAuth2PasswordRequestForm\n\nThird Party: sqlalchemy.orm\n  - Session\n\nLocal: app.core.database\n  - get_db\n\nLocal: app.core.security\n  - verify_password, create_access_token, get_password_hash\n\nLocal: app.models.user\n  - User\n\nLocal: app.schemas.user\n  - UserCreate, UserResponse, Token\n\nLocal: app.core.security\n  - get_current_user_id",
      "metadata": {
        "file_path": "app/api/v1/endpoints/auth.py",
        "chunk_type": "imports",
        "name": "module_imports",
        "purpose": "Module dependencies and imports",
        "dependencies": [],
        "access_level": "public",
        "imports": [
          {
            "module": "fastapi",
            "type": "third_party",
            "items": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "status"
            ]
          },
          {
            "module": "fastapi.security",
            "type": "third_party",
            "items": [
              "OAuth2PasswordBearer",
              "OAuth2PasswordRequestForm"
            ]
          },
          {
            "module": "sqlalchemy.orm",
            "type": "third_party",
            "items": [
              "Session"
            ]
          },
          {
            "module": "app.core.database",
            "type": "local",
            "items": [
              "get_db"
            ]
          },
          {
            "module": "app.core.security",
            "type": "local",
            "items": [
              "verify_password",
              "create_access_token",
              "get_password_hash"
            ]
          },
          {
            "module": "app.models.user",
            "type": "local",
            "items": [
              "User"
            ]
          },
          {
            "module": "app.schemas.user",
            "type": "local",
            "items": [
              "UserCreate",
              "UserResponse",
              "Token"
            ]
          },
          {
            "module": "app.core.security",
            "type": "local",
            "items": [
              "get_current_user_id"
            ]
          }
        ]
      },
      "description": "The `module_imports` Python module is designed to manage dependencies and imports essential for building a web application using FastAPI and SQLAlchemy. It relies on several third-party libraries, including FastAPI for creating APIs, with specific imports such as `APIRouter` for routing, `Depends` for dependency injection, `HTTPException` for error handling, and `status` for HTTP status codes. Additionally, it uses FastAPI's security features, importing `OAuth2PasswordBearer` and `OAuth2PasswordRequestForm` for implementing OAuth2 authentication.\n\nThe module also incorporates SQLAlchemy's ORM capabilities through the `Session` import, facilitating database interactions. Locally, it connects to various components of the application, such as `get_db` from `app.core.database` for database session management, and security functions like `verify_password`, `create_access_token`, and `get_password_hash` from `app.core.security` for user authentication and token generation. It further includes user-related models and schemas"
    },
    {
      "type": "imports",
      "name": "module_imports",
      "content": "Module Dependencies:\n\nStandard Library: typing\n  - List\n\nThird Party: fastapi\n  - APIRouter, Depends, HTTPException, status, Query\n\nThird Party: sqlalchemy.orm\n  - Session\n\nLocal: app.core.database\n  - get_db\n\nLocal: app.core.security\n  - require_auth\n\nLocal: app.models.user\n  - User\n\nLocal: app.schemas.user\n  - UserResponse, UserUpdate",
      "metadata": {
        "file_path": "app/api/v1/endpoints/users.py",
        "chunk_type": "imports",
        "name": "module_imports",
        "purpose": "Module dependencies and imports",
        "dependencies": [],
        "access_level": "public",
        "imports": [
          {
            "module": "typing",
            "type": "standard",
            "items": [
              "List"
            ]
          },
          {
            "module": "fastapi",
            "type": "third_party",
            "items": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "status",
              "Query"
            ]
          },
          {
            "module": "sqlalchemy.orm",
            "type": "third_party",
            "items": [
              "Session"
            ]
          },
          {
            "module": "app.core.database",
            "type": "local",
            "items": [
              "get_db"
            ]
          },
          {
            "module": "app.core.security",
            "type": "local",
            "items": [
              "require_auth"
            ]
          },
          {
            "module": "app.models.user",
            "type": "local",
            "items": [
              "User"
            ]
          },
          {
            "module": "app.schemas.user",
            "type": "local",
            "items": [
              "UserResponse",
              "UserUpdate"
            ]
          }
        ]
      },
      "description": "The `module_imports` Python module manages essential dependencies and imports for a web application built with FastAPI and SQLAlchemy. It utilizes the standard library's `typing` for type annotations, specifically the `List` type. The module incorporates several third-party libraries: FastAPI for building APIs, providing components like `APIRouter` for routing, `Depends` for dependency injection, `HTTPException` for error handling, `status` for HTTP status codes, and `Query` for query parameter handling. Additionally, it imports `Session` from `sqlalchemy.orm` for database session management.\n\nLocally, the module integrates with the application's core components, importing `get_db` from `app.core.database` for database connections, `require_auth` from `app.core.security` for authentication enforcement, `User` from `app.models.user` to represent user data, and `UserResponse` and `UserUpdate` from `app.schemas.user` for data serialization and validation. This structure facilitates"
    },
    {
      "type": "imports",
      "name": "module_imports",
      "content": "Module Dependencies:\n\nStandard Library: typing\n  - List\n\nThird Party: fastapi\n  - APIRouter, Depends, HTTPException, status, Query\n\nThird Party: sqlalchemy.orm\n  - Session\n\nLocal: app.core.database\n  - get_db\n\nLocal: app.core.security\n  - require_auth\n\nLocal: app.models.category\n  - Category\n\nLocal: app.models.user\n  - User\n\nLocal: app.schemas.category\n  - CategoryCreate, CategoryUpdate, CategoryResponse",
      "metadata": {
        "file_path": "app/api/v1/endpoints/categories.py",
        "chunk_type": "imports",
        "name": "module_imports",
        "purpose": "Module dependencies and imports",
        "dependencies": [],
        "access_level": "public",
        "imports": [
          {
            "module": "typing",
            "type": "standard",
            "items": [
              "List"
            ]
          },
          {
            "module": "fastapi",
            "type": "third_party",
            "items": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "status",
              "Query"
            ]
          },
          {
            "module": "sqlalchemy.orm",
            "type": "third_party",
            "items": [
              "Session"
            ]
          },
          {
            "module": "app.core.database",
            "type": "local",
            "items": [
              "get_db"
            ]
          },
          {
            "module": "app.core.security",
            "type": "local",
            "items": [
              "require_auth"
            ]
          },
          {
            "module": "app.models.category",
            "type": "local",
            "items": [
              "Category"
            ]
          },
          {
            "module": "app.models.user",
            "type": "local",
            "items": [
              "User"
            ]
          },
          {
            "module": "app.schemas.category",
            "type": "local",
            "items": [
              "CategoryCreate",
              "CategoryUpdate",
              "CategoryResponse"
            ]
          }
        ]
      },
      "description": "The `module_imports` Python module manages dependencies and imports essential for the applications functionality. It utilizes the standard library's `typing` for type hints, specifically the `List` type. The module integrates several third-party libraries: \n\n- **FastAPI**: Provides web framework capabilities with components such as `APIRouter` for routing, `Depends` for dependency injection, `HTTPException` for error handling, `status` for HTTP status codes, and `Query` for query parameter handling.\n- **SQLAlchemy ORM**: Facilitates database interactions through the `Session` class, enabling efficient database session management.\n\nAdditionally, the module includes local imports that contribute to the application's core functionalities:\n\n- **Database Management**: `get_db` from `app.core.database` manages database connections.\n- **Authentication**: `require_auth` from `app.core.security` ensures secure access control.\n- **Data Models**: `Category` and `User` from `app.models` define"
    },
    {
      "type": "imports",
      "name": "module_imports",
      "content": "Module Dependencies:\n\nStandard Library: typing\n  - List, Optional\n\nThird Party: fastapi\n  - APIRouter, Depends, HTTPException, status, Query\n\nThird Party: sqlalchemy.orm\n  - Session\n\nThird Party: sqlalchemy\n  - or_\n\nLocal: app.core.database\n  - get_db\n\nLocal: app.core.security\n  - require_auth\n\nLocal: app.models.product\n  - Product, ProductImage\n\nLocal: app.models.user\n  - User\n\nLocal: app.schemas.product\n  - ProductCreate, ProductUpdate, ProductResponse, ProductListResponse",
      "metadata": {
        "file_path": "app/api/v1/endpoints/products.py",
        "chunk_type": "imports",
        "name": "module_imports",
        "purpose": "Module dependencies and imports",
        "dependencies": [],
        "access_level": "public",
        "imports": [
          {
            "module": "typing",
            "type": "standard",
            "items": [
              "List",
              "Optional"
            ]
          },
          {
            "module": "fastapi",
            "type": "third_party",
            "items": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "status",
              "Query"
            ]
          },
          {
            "module": "sqlalchemy.orm",
            "type": "third_party",
            "items": [
              "Session"
            ]
          },
          {
            "module": "sqlalchemy",
            "type": "third_party",
            "items": [
              "or_"
            ]
          },
          {
            "module": "app.core.database",
            "type": "local",
            "items": [
              "get_db"
            ]
          },
          {
            "module": "app.core.security",
            "type": "local",
            "items": [
              "require_auth"
            ]
          },
          {
            "module": "app.models.product",
            "type": "local",
            "items": [
              "Product",
              "ProductImage"
            ]
          },
          {
            "module": "app.models.user",
            "type": "local",
            "items": [
              "User"
            ]
          },
          {
            "module": "app.schemas.product",
            "type": "local",
            "items": [
              "ProductCreate",
              "ProductUpdate",
              "ProductResponse",
              "ProductListResponse"
            ]
          }
        ]
      },
      "description": "The `module_imports` module outlines the dependencies and imports necessary for a Python application, primarily focused on web development and database interactions. It utilizes the standard library's `typing` for type hints, specifically `List` and `Optional`, enhancing code clarity and type safety.\n\nThis module incorporates several third-party libraries:\n- **FastAPI**: Provides essential components for building APIs, including `APIRouter` for routing, `Depends` for dependency injection, `HTTPException` for error handling, `status` for HTTP status codes, and `Query` for query parameter handling.\n- **SQLAlchemy**: Facilitates database interactions, with `Session` for managing database sessions and `or_` for constructing complex queries.\n\nAdditionally, the module imports local components that are integral to the application:\n- **Database Access**: `get_db` from `app.core.database` for database session management.\n- **Security**: `require_auth` from `app.core.security` for authentication requirements."
    },
    {
      "type": "imports",
      "name": "module_imports",
      "content": "Module Dependencies:\n\nStandard Library: typing\n  - List\n\nThird Party: fastapi\n  - APIRouter, Depends, HTTPException, status, Query\n\nThird Party: sqlalchemy.orm\n  - Session\n\nThird Party: sqlalchemy\n  - desc\n\nLocal: app.core.database\n  - get_db\n\nLocal: app.core.security\n  - require_auth\n\nLocal: app.models.order\n  - Order, OrderItem, OrderStatus\n\nLocal: app.models.product\n  - Product\n\nLocal: app.models.user\n  - User\n\nLocal: app.schemas.order\n  - OrderCreate, OrderUpdate, OrderResponse, OrderListResponse\n\nThird Party: uuid\n  - uuid",
      "metadata": {
        "file_path": "app/api/v1/endpoints/orders.py",
        "chunk_type": "imports",
        "name": "module_imports",
        "purpose": "Module dependencies and imports",
        "dependencies": [],
        "access_level": "public",
        "imports": [
          {
            "module": "typing",
            "type": "standard",
            "items": [
              "List"
            ]
          },
          {
            "module": "fastapi",
            "type": "third_party",
            "items": [
              "APIRouter",
              "Depends",
              "HTTPException",
              "status",
              "Query"
            ]
          },
          {
            "module": "sqlalchemy.orm",
            "type": "third_party",
            "items": [
              "Session"
            ]
          },
          {
            "module": "sqlalchemy",
            "type": "third_party",
            "items": [
              "desc"
            ]
          },
          {
            "module": "app.core.database",
            "type": "local",
            "items": [
              "get_db"
            ]
          },
          {
            "module": "app.core.security",
            "type": "local",
            "items": [
              "require_auth"
            ]
          },
          {
            "module": "app.models.order",
            "type": "local",
            "items": [
              "Order",
              "OrderItem",
              "OrderStatus"
            ]
          },
          {
            "module": "app.models.product",
            "type": "local",
            "items": [
              "Product"
            ]
          },
          {
            "module": "app.models.user",
            "type": "local",
            "items": [
              "User"
            ]
          },
          {
            "module": "app.schemas.order",
            "type": "local",
            "items": [
              "OrderCreate",
              "OrderUpdate",
              "OrderResponse",
              "OrderListResponse"
            ]
          },
          {
            "module": "uuid",
            "type": "third_party",
            "items": [
              "uuid"
            ]
          }
        ]
      },
      "description": "The `module_imports` Python module manages various dependencies essential for its functionality. It utilizes the standard library's `typing` for type hinting, specifically the `List` type. The module integrates several third-party libraries, including:\n\n- **FastAPI**: Provides web framework capabilities with components like `APIRouter` for routing, `Depends` for dependency injection, `HTTPException` for error handling, and `status` and `Query` for managing HTTP status codes and query parameters.\n- **SQLAlchemy**: Utilizes `sqlalchemy.orm.Session` for database session management and `sqlalchemy.desc` for ordering query results.\n- **UUID**: Implements unique identifier generation through the `uuid` module.\n\nAdditionally, the module includes local imports from the application's core and models, such as:\n\n- **Database**: `get_db` function for database connection management.\n- **Security**: `require_auth` function for authentication requirements.\n- **Models**: Represents business entities like"
    },
    {
      "type": "package",
      "name": "app.api.v1",
      "content": "Package: app.api.v1\nPurpose: API endpoints and HTTP handling\n\nContains 6 files:\n- auth.py\n- categories.py\n- orders.py\n- products.py\n- users.py\n- router.py\n",
      "metadata": {
        "file_path": "app/api/v1",
        "chunk_type": "package",
        "name": "app.api.v1",
        "purpose": "API endpoints and HTTP handling",
        "dependencies": [],
        "access_level": "public",
        "file_count": 6,
        "files": [
          "router.py",
          "auth.py",
          "users.py",
          "categories.py",
          "products.py",
          "orders.py"
        ],
        "subpackages": [],
        "api_routes": [],
        "database_tables": [],
        "features": []
      },
      "description": "**Package Description: app.api.v1**\n\nThe `app.api.v1` package serves as the primary interface for API endpoints and HTTP request handling within the application. It consists of six key modules: `auth.py`, `categories.py`, `orders.py`, `products.py`, `users.py`, and `router.py`. \n\n**Functionality**: \n- **auth.py**: Manages user authentication and authorization processes.\n- **categories.py**: Handles CRUD operations for product categories.\n- **orders.py**: Facilitates order management, including creation and tracking.\n- **products.py**: Manages product listings and details.\n- **users.py**: Oversees user account management and profile operations.\n- **router.py**: Centralizes routing of API requests to the appropriate modules.\n\n**Usage Context**: Developers utilize this package when building RESTful APIs for web applications, particularly in e-commerce or service-oriented architectures. It is essential for creating scalable and maintainable API endpoints that interact"
    },
    {
      "type": "package",
      "name": "app.api.v1.endpoints",
      "content": "Package: app.api.v1.endpoints\nPurpose: API endpoints and HTTP handling\n\nContains 5 files:\n- auth.py\n- categories.py\n- orders.py\n- products.py\n- users.py\n",
      "metadata": {
        "file_path": "app/api/v1/endpoints",
        "chunk_type": "package",
        "name": "app.api.v1.endpoints",
        "purpose": "API endpoints and HTTP handling",
        "dependencies": [],
        "access_level": "public",
        "file_count": 5,
        "files": [
          "auth.py",
          "users.py",
          "categories.py",
          "products.py",
          "orders.py"
        ],
        "subpackages": [],
        "api_routes": [],
        "database_tables": [],
        "features": []
      },
      "description": "**Package Description: app.api.v1.endpoints**\n\nThe `app.api.v1.endpoints` package serves as the core module for managing API endpoints and HTTP request handling within a web application. It encapsulates five key files: `auth.py`, `categories.py`, `orders.py`, `products.py`, and `users.py`, each responsible for specific functionalities related to user authentication, product categorization, order processing, product management, and user management, respectively.\n\n**Functionality:**\n- **auth.py**: Manages user authentication and authorization processes.\n- **categories.py**: Handles operations related to product categories, including retrieval and modification.\n- **orders.py**: Facilitates order creation, tracking, and management.\n- **products.py**: Manages product listings, details, and inventory.\n- **users.py**: Oversees user account creation, updates, and profile management.\n\n**Use Cases:**\nDevelopers would utilize this package when building RESTful APIs for e-commerce or"
    },
    {
      "type": "package",
      "name": "app.core",
      "content": "Package: app.core\nPurpose: Core application configuration\n\nContains 14 files:\n- config.py\n- config.py\n- config.py\n- config.py\n- database.py\n- database.py\n- database.py\n- security.py\n- security.py\n- security.py\n- security.py\n- security.py\n- security.py\n- security.py\n\nFeatures:\n- Functions: create_access_token\n- Functions: verify_password\n- Functions: get_db_session\n- Classes: Config\n- Functions: get_password_hash\n- Functions: require_auth\n- Classes: Settings\n- Functions: assemble_cors_origins\n- Functions: get_current_user_id\n- Functions: get_db\n- Functions: verify_token\n",
      "metadata": {
        "file_path": "app/core",
        "chunk_type": "package",
        "name": "app.core",
        "purpose": "Core application configuration",
        "dependencies": [],
        "access_level": "public",
        "file_count": 14,
        "files": [
          "config.py",
          "config.py",
          "config.py",
          "config.py",
          "database.py",
          "database.py",
          "database.py",
          "security.py",
          "security.py",
          "security.py",
          "security.py",
          "security.py",
          "security.py",
          "security.py"
        ],
        "subpackages": [],
        "api_routes": [],
        "database_tables": [],
        "features": [
          "Functions: create_access_token",
          "Functions: verify_password",
          "Functions: get_db_session",
          "Classes: Config",
          "Functions: get_password_hash",
          "Functions: require_auth",
          "Classes: Settings",
          "Functions: assemble_cors_origins",
          "Functions: get_current_user_id",
          "Functions: get_db",
          "Functions: verify_token"
        ]
      },
      "description": "**Package Description: app.core**\n\nThe `app.core` package serves as the foundational configuration module for an application, encapsulating essential settings and functionalities required for application operation. It comprises 14 files, primarily focusing on configuration management, database interactions, and security features.\n\n**Functionality:**\n- **Configuration Management:** Classes like `Config` and `Settings` manage application settings.\n- **Database Operations:** Functions such as `get_db` and `get_db_session` facilitate database connectivity and session management.\n- **Security Features:** Functions like `create_access_token`, `verify_password`, and `verify_token` handle user authentication and authorization, while `get_password_hash` ensures secure password storage.\n- **CORS Management:** The `assemble_cors_origins` function configures Cross-Origin Resource Sharing (CORS) settings.\n\n**Usage Context:**\nDevelopers would utilize this package when building applications that require robust configuration management, secure user authentication, and efficient database handling. It is particularly useful in"
    },
    {
      "type": "package",
      "name": "app.models",
      "content": "Package: app.models\nPurpose: Database models and data structures\n\nContains 29 files:\n- __init__.py\n- category.py\n- category.py\n- category.py\n- category.py\n- category.py\n- order.py\n- order.py\n- order.py\n- order.py\n- order.py\n- order.py\n- order.py\n- order.py\n- order.py\n- order.py\n- product.py\n- product.py\n- product.py\n- product.py\n- product.py\n- product.py\n- product.py\n- product.py\n- user.py\n- user.py\n- user.py\n- user.py\n- user.py\n\nFeatures:\n- Functions: to_dict\n- Classes: User\n- Classes: Product\n- Functions: is_in_stock\n- Classes: ProductImage\n- Classes: Category\n- Classes: Order\n- Functions: __repr__\n- Classes: OrderItem\n- Functions: item_count\n- Functions: full_name\n- Classes: OrderStatus\n- Functions: product_count\n",
      "metadata": {
        "file_path": "app/models",
        "chunk_type": "package",
        "name": "app.models",
        "purpose": "Database models and data structures",
        "dependencies": [],
        "access_level": "public",
        "file_count": 29,
        "files": [
          "user.py",
          "user.py",
          "user.py",
          "user.py",
          "user.py",
          "order.py",
          "order.py",
          "order.py",
          "order.py",
          "order.py",
          "order.py",
          "order.py",
          "order.py",
          "order.py",
          "order.py",
          "__init__.py",
          "product.py",
          "product.py",
          "product.py",
          "product.py",
          "product.py",
          "product.py",
          "product.py",
          "product.py",
          "category.py",
          "category.py",
          "category.py",
          "category.py",
          "category.py"
        ],
        "subpackages": [],
        "api_routes": [],
        "database_tables": [],
        "features": [
          "Functions: to_dict",
          "Classes: User",
          "Classes: Product",
          "Functions: is_in_stock",
          "Classes: ProductImage",
          "Classes: Category",
          "Classes: Order",
          "Functions: __repr__",
          "Classes: OrderItem",
          "Functions: item_count",
          "Functions: full_name",
          "Classes: OrderStatus",
          "Functions: product_count"
        ]
      },
      "description": "**Package: app.models**\n\n**Description:**\nThe `app.models` package serves as the foundational layer for database models and data structures within the application. It encapsulates the core entities such as `User`, `Product`, `Category`, `Order`, and their associated functionalities, enabling structured data management and interactions with the database.\n\n**Functionality:**\nThis package includes 29 files that define essential classes and functions for handling application data. Key classes include:\n- **User**: Represents application users with methods for user-related operations.\n- **Product**: Manages product details, including stock status and image handling.\n- **Category**: Organizes products into categories for better navigation.\n- **Order**: Handles order processing and status tracking.\n- **OrderItem**: Represents individual items within an order.\n- **OrderStatus**: Enumerates the various statuses an order can have.\n\nThe package also provides utility functions such as `to_dict`, `is_in_stock`, `item_count`,"
    },
    {
      "type": "package",
      "name": "app.schemas",
      "content": "Package: app.schemas\nPurpose: Data validation and serialization\n\nContains 45 files:\n- __init__.py\n- category.py\n- category.py\n- category.py\n- category.py\n- category.py\n- category.py\n- category.py\n- category.py\n- order.py\n- order.py\n- order.py\n- order.py\n- order.py\n- order.py\n- order.py\n- order.py\n- order.py\n- order.py\n- order.py\n- order.py\n- order.py\n- product.py\n- product.py\n- product.py\n- product.py\n- product.py\n- product.py\n- product.py\n- product.py\n- product.py\n- product.py\n- product.py\n- product.py\n- product.py\n- user.py\n- user.py\n- user.py\n- user.py\n- user.py\n- user.py\n- user.py\n- user.py\n- user.py\n- user.py\n\nFeatures:\n- Functions: validate_username\n- Classes: OrderResponse\n- Classes: ProductImageBase\n- Classes: ProductImageCreate\n- Classes: Token\n- Functions: validate_password\n- Functions: validate_price\n- Classes: ProductBase\n- Functions: validate_stock\n- Classes: ProductCreate\n- Classes: UserCreate\n- Classes: CategoryResponse\n- Classes: OrderItemBase\n- Functions: validate_name\n- Classes: OrderListResponse\n- Functions: validate_items\n- Classes: ProductUpdate\n- Classes: Config\n- Classes: OrderItemCreate\n- Classes: OrderBase\n- Classes: UserUpdate\n- Functions: validate_slug\n- Classes: CategoryBase\n- Classes: UserLogin\n- Classes: UserBase\n- Classes: UserResponse\n- Classes: ProductResponse\n- Classes: ProductListResponse\n- Classes: OrderItemResponse\n- Classes: OrderUpdate\n- Classes: OrderCreate\n- Functions: validate_quantity\n- Classes: ProductImageResponse\n- Classes: CategoryCreate\n- Classes: CategoryUpdate\n",
      "metadata": {
        "file_path": "app/schemas",
        "chunk_type": "package",
        "name": "app.schemas",
        "purpose": "Data validation and serialization",
        "dependencies": [],
        "access_level": "public",
        "file_count": 45,
        "files": [
          "user.py",
          "user.py",
          "user.py",
          "user.py",
          "user.py",
          "user.py",
          "user.py",
          "user.py",
          "user.py",
          "user.py",
          "order.py",
          "order.py",
          "order.py",
          "order.py",
          "order.py",
          "order.py",
          "order.py",
          "order.py",
          "order.py",
          "order.py",
          "order.py",
          "order.py",
          "order.py",
          "__init__.py",
          "product.py",
          "product.py",
          "product.py",
          "product.py",
          "product.py",
          "product.py",
          "product.py",
          "product.py",
          "product.py",
          "product.py",
          "product.py",
          "product.py",
          "product.py",
          "category.py",
          "category.py",
          "category.py",
          "category.py",
          "category.py",
          "category.py",
          "category.py",
          "category.py"
        ],
        "subpackages": [],
        "api_routes": [],
        "database_tables": [],
        "features": [
          "Functions: validate_username",
          "Classes: OrderResponse",
          "Classes: ProductImageBase",
          "Classes: ProductImageCreate",
          "Classes: Token",
          "Functions: validate_password",
          "Functions: validate_price",
          "Classes: ProductBase",
          "Functions: validate_stock",
          "Classes: ProductCreate",
          "Classes: UserCreate",
          "Classes: CategoryResponse",
          "Classes: OrderItemBase",
          "Functions: validate_name",
          "Classes: OrderListResponse",
          "Functions: validate_items",
          "Classes: ProductUpdate",
          "Classes: Config",
          "Classes: OrderItemCreate",
          "Classes: OrderBase",
          "Classes: UserUpdate",
          "Functions: validate_slug",
          "Classes: CategoryBase",
          "Classes: UserLogin",
          "Classes: UserBase",
          "Classes: UserResponse",
          "Classes: ProductResponse",
          "Classes: ProductListResponse",
          "Classes: OrderItemResponse",
          "Classes: OrderUpdate",
          "Classes: OrderCreate",
          "Functions: validate_quantity",
          "Classes: ProductImageResponse",
          "Classes: CategoryCreate",
          "Classes: CategoryUpdate"
        ]
      },
      "description": "**Package: app.schemas**\n\n**Description:**  \nThe `app.schemas` package is designed for data validation and serialization within a Python application. It consists of 45 files, including essential modules for managing data structures related to categories, orders, products, and users. This package ensures that data conforms to specified formats and constraints, enhancing data integrity and consistency across the application.\n\n**Functionality:**  \nKey functionalities include:\n- **Data Validation:** Functions like `validate_username` and `validate_password` ensure that user inputs meet predefined criteria.\n- **Serialization Classes:** Classes such as `OrderResponse`, `ProductImageBase`, and `ProductImageCreate` facilitate the conversion of complex data types into JSON-compatible formats, making it easier to transmit data over APIs.\n\n**Use Cases for Developers:**  \nDevelopers would utilize this package when implementing features that require strict data validation or when preparing data for API responses. It is particularly useful in e-commerce applications where managing product, order, and user data is critical."
    },
    {
      "type": "package",
      "name": "app.services",
      "content": "Package: app.services\nPurpose: Business logic and external integrations\n\nContains 14 files:\n- email.py\n- email.py\n- email.py\n- email.py\n- email.py\n- email.py\n- email.py\n- notification.py\n- notification.py\n- notification.py\n- notification.py\n- notification.py\n- notification.py\n- notification.py\n\nFeatures:\n- Functions: send_email\n- Classes: NotificationService\n- Functions: publish_notification\n- Functions: __init__\n- Functions: send_password_reset\n- Functions: notify_system_alert\n- Functions: send_bulk_email\n- Classes: EmailService\n- Functions: notify_stock_update\n- Functions: send_order_confirmation\n- Functions: notify_order_update\n",
      "metadata": {
        "file_path": "app/services",
        "chunk_type": "package",
        "name": "app.services",
        "purpose": "Business logic and external integrations",
        "dependencies": [],
        "access_level": "public",
        "file_count": 14,
        "files": [
          "notification.py",
          "notification.py",
          "notification.py",
          "notification.py",
          "notification.py",
          "notification.py",
          "notification.py",
          "email.py",
          "email.py",
          "email.py",
          "email.py",
          "email.py",
          "email.py",
          "email.py"
        ],
        "subpackages": [],
        "api_routes": [],
        "database_tables": [],
        "features": [
          "Functions: send_email",
          "Classes: NotificationService",
          "Functions: publish_notification",
          "Functions: __init__",
          "Functions: send_password_reset",
          "Functions: notify_system_alert",
          "Functions: send_bulk_email",
          "Classes: EmailService",
          "Functions: notify_stock_update",
          "Functions: send_order_confirmation",
          "Functions: notify_order_update"
        ]
      },
      "description": "**Package Description: app.services**\n\nThe `app.services` package is integral to the business logic layer of an application, facilitating external integrations primarily related to email and notification management. This package comprises 14 files, predominantly focused on handling email communications and notifications.\n\n**Functionality:**\n- **Email Management:** The `EmailService` class provides methods for sending various types of emails, including order confirmations, password resets, and bulk emails.\n- **Notification Handling:** The `NotificationService` class manages system alerts and updates, offering functions to publish notifications and notify users about stock updates and order changes.\n\n**Use Cases:**\nDevelopers would utilize this package when implementing features that require automated email notifications or alerts, such as e-commerce platforms, user account management systems, or any application needing timely communication with users.\n\n**Architectural Fit:**\nThis package serves as a bridge between the applications core business logic and external communication channels, ensuring that users receive relevant updates and notifications. It enhances the overall architecture by"
    },
    {
      "type": "package",
      "name": "app.utils",
      "content": "Package: app.utils\nPurpose: Utility functions and helpers\n\nContains 31 files:\n- helpers.py\n- helpers.py\n- helpers.py\n- helpers.py\n- helpers.py\n- helpers.py\n- helpers.py\n- helpers.py\n- helpers.py\n- helpers.py\n- helpers.py\n- helpers.py\n- helpers.py\n- helpers.py\n- helpers.py\n- helpers.py\n- helpers.py\n- helpers.py\n- helpers.py\n- helpers.py\n- validators.py\n- validators.py\n- validators.py\n- validators.py\n- validators.py\n- validators.py\n- validators.py\n- validators.py\n- validators.py\n- validators.py\n- validators.py\n\nFeatures:\n- Functions: merge_dicts\n- Functions: sanitize_string\n- Functions: round_to_cents\n- Functions: filter_dict\n- Functions: get_date_range_days\n- Functions: validate_phone\n- Functions: calculate_shipping\n- Functions: generate_hash\n- Functions: truncate_string\n- Functions: calculate_tax\n- Functions: validate_price\n- Functions: paginate_results\n- Functions: validate_dimensions\n- Functions: validate_password_strength\n- Functions: validate_sku\n- Functions: generate_short_id\n- Functions: validate_stock_quantity\n- Functions: format_datetime\n- Functions: is_valid_date_range\n- Functions: validate_slug\n- Functions: safe_divide\n- Functions: parse_datetime\n- Functions: generate_slug\n- Functions: deep_merge_dicts\n- Functions: generate_uuid\n- Functions: remove_duplicates\n- Functions: format_currency\n- Functions: chunk_list\n- Functions: validate_email\n",
      "metadata": {
        "file_path": "app/utils",
        "chunk_type": "package",
        "name": "app.utils",
        "purpose": "Utility functions and helpers",
        "dependencies": [],
        "access_level": "public",
        "file_count": 31,
        "files": [
          "validators.py",
          "validators.py",
          "validators.py",
          "validators.py",
          "validators.py",
          "validators.py",
          "validators.py",
          "validators.py",
          "validators.py",
          "validators.py",
          "validators.py",
          "helpers.py",
          "helpers.py",
          "helpers.py",
          "helpers.py",
          "helpers.py",
          "helpers.py",
          "helpers.py",
          "helpers.py",
          "helpers.py",
          "helpers.py",
          "helpers.py",
          "helpers.py",
          "helpers.py",
          "helpers.py",
          "helpers.py",
          "helpers.py",
          "helpers.py",
          "helpers.py",
          "helpers.py",
          "helpers.py"
        ],
        "subpackages": [],
        "api_routes": [],
        "database_tables": [],
        "features": [
          "Functions: merge_dicts",
          "Functions: sanitize_string",
          "Functions: round_to_cents",
          "Functions: filter_dict",
          "Functions: get_date_range_days",
          "Functions: validate_phone",
          "Functions: calculate_shipping",
          "Functions: generate_hash",
          "Functions: truncate_string",
          "Functions: calculate_tax",
          "Functions: validate_price",
          "Functions: paginate_results",
          "Functions: validate_dimensions",
          "Functions: validate_password_strength",
          "Functions: validate_sku",
          "Functions: generate_short_id",
          "Functions: validate_stock_quantity",
          "Functions: format_datetime",
          "Functions: is_valid_date_range",
          "Functions: validate_slug",
          "Functions: safe_divide",
          "Functions: parse_datetime",
          "Functions: generate_slug",
          "Functions: deep_merge_dicts",
          "Functions: generate_uuid",
          "Functions: remove_duplicates",
          "Functions: format_currency",
          "Functions: chunk_list",
          "Functions: validate_email"
        ]
      },
      "description": "**Package: app.utils**\n\n**Description:**  \nThe `app.utils` package serves as a collection of utility functions and helper methods designed to streamline common programming tasks within an application. Comprising 31 files, primarily focused on `helpers.py` and `validators.py`, this package enhances code reusability and maintainability.\n\n**Functionality:**  \nKey features include:\n- **Data Manipulation:** Functions like `merge_dicts`, `filter_dict`, and `sanitize_string` facilitate efficient data handling.\n- **Validation:** The `validate_phone` function ensures proper formatting of phone numbers, while other validators can be added as needed.\n- **Financial Calculations:** Functions such as `round_to_cents` and `calculate_shipping` assist in accurate monetary computations.\n- **String Operations:** Methods like `truncate_string` and `generate_hash` support string management and security.\n- **Date Handling:** The `get_date_range_days` function aids in date-related calculations.\n\n**Use Cases:**  \nDevelop"
    },
    {
      "type": "package",
      "name": "tests",
      "content": "Package: tests\nPurpose: Test files and test utilities\n\nContains 23 files:\n- test_auth.py\n- test_auth.py\n- test_auth.py\n- test_auth.py\n- test_auth.py\n- test_auth.py\n- test_auth.py\n- test_auth.py\n- test_products.py\n- test_products.py\n- test_products.py\n- test_products.py\n- test_products.py\n- test_products.py\n- test_products.py\n- test_products.py\n- test_products.py\n- test_products.py\n- test_products.py\n- test_products.py\n- test_products.py\n- test_products.py\n- test_products.py\n\nFeatures:\n- Functions: test_get_current_user_invalid_token\n- Functions: test_delete_product_as_admin\n- Functions: test_register_user\n- Functions: test_login_success\n- Functions: test_create_product_as_regular_user\n- Functions: test_get_products_with_filters\n- Functions: admin_user\n- Functions: test_register_duplicate_email\n- Functions: test_product\n- Functions: test_get_product_by_id\n- Functions: test_get_products\n- Functions: test_user\n- Functions: get_auth_headers\n- Functions: test_create_product_duplicate_sku\n- Functions: test_update_product_as_admin\n- Functions: test_create_product_as_admin\n- Functions: test_category\n- Functions: test_login_invalid_credentials\n- Functions: test_get_current_user\n- Functions: regular_user\n- Functions: test_get_nonexistent_product\n",
      "metadata": {
        "file_path": "tests",
        "chunk_type": "package",
        "name": "tests",
        "purpose": "Test files and test utilities",
        "dependencies": [],
        "access_level": "public",
        "file_count": 23,
        "files": [
          "test_products.py",
          "test_products.py",
          "test_products.py",
          "test_products.py",
          "test_products.py",
          "test_products.py",
          "test_products.py",
          "test_products.py",
          "test_products.py",
          "test_products.py",
          "test_products.py",
          "test_products.py",
          "test_products.py",
          "test_products.py",
          "test_products.py",
          "test_auth.py",
          "test_auth.py",
          "test_auth.py",
          "test_auth.py",
          "test_auth.py",
          "test_auth.py",
          "test_auth.py",
          "test_auth.py"
        ],
        "subpackages": [],
        "api_routes": [],
        "database_tables": [],
        "features": [
          "Functions: test_get_current_user_invalid_token",
          "Functions: test_delete_product_as_admin",
          "Functions: test_register_user",
          "Functions: test_login_success",
          "Functions: test_create_product_as_regular_user",
          "Functions: test_get_products_with_filters",
          "Functions: admin_user",
          "Functions: test_register_duplicate_email",
          "Functions: test_product",
          "Functions: test_get_product_by_id",
          "Functions: test_get_products",
          "Functions: test_user",
          "Functions: get_auth_headers",
          "Functions: test_create_product_duplicate_sku",
          "Functions: test_update_product_as_admin",
          "Functions: test_create_product_as_admin",
          "Functions: test_category",
          "Functions: test_login_invalid_credentials",
          "Functions: test_get_current_user",
          "Functions: regular_user",
          "Functions: test_get_nonexistent_product"
        ]
      },
      "description": "**Package: tests**\n\n**Description:**  \nThe `tests` package is designed to facilitate automated testing for a software application, specifically focusing on user authentication and product management functionalities. It contains 23 test files, primarily divided into two categories: `test_auth.py` and `test_products.py`, which ensure the reliability and correctness of the applications core features.\n\n**Functionality:**  \nThis package provides a suite of test functions that validate various aspects of the application, including:\n- User authentication processes (e.g., `test_login_success`, `test_register_user`, `test_get_current_user_invalid_token`)\n- Product management operations (e.g., `test_create_product_as_regular_user`, `test_delete_product_as_admin`, `test_get_products_with_filters`)\n- Handling edge cases such as duplicate user registrations (e.g., `test_register_duplicate_e`)\n\n**Use Case:**  \nDevelopers utilize this package during the development lifecycle to verify that new code changes do not introduce regressions or bugs. It"
    }
  ],
  "relationships": [
    {
      "type": "contains",
      "source": "app/core/config.py:Settings",
      "target": "app/core/config.py:Settings.assemble_cors_origins",
      "metadata": {
        "purpose": "class_method"
      }
    },
    {
      "type": "method",
      "name": "Settings.assemble_cors_origins",
      "content": "    def assemble_cors_origins(cls, v):\n        if isinstance(v, str):\n            return [i.strip() for i in v.split(\",\")]\n        return v",
      "metadata": {
        "file_path": "app/core/config.py",
        "chunk_type": "method",
        "name": "Settings.assemble_cors_origins",
        "purpose": "Method assemble_cors_origins",
        "dependencies": [],
        "access_level": "public",
        "class_name": "Settings",
        "method_name": "assemble_cors_origins",
        "parameters": [
          "cls",
          "v"
        ],
        "return_type": "",
        "access": "public",
        "decorators": [
          "validator('ALLOWED_HOSTS', pre=True)"
        ],
        "is_async": false,
        "is_static": false,
        "is_classmethod": false
      }
    },
    {
      "type": "contains",
      "source": "app/models/user.py:User",
      "target": "app/models/user.py:User.__repr__",
      "metadata": {
        "purpose": "class_method"
      }
    },
    {
      "type": "contains",
      "source": "app/models/user.py:User",
      "target": "app/models/user.py:User.full_name",
      "metadata": {
        "purpose": "class_method"
      }
    },
    {
      "type": "contains",
      "source": "app/models/user.py:User",
      "target": "app/models/user.py:User.to_dict",
      "metadata": {
        "purpose": "class_method"
      }
    },
    {
      "type": "method",
      "name": "User.__repr__",
      "content": "    def __repr__(self):\n        return f\"<User(id={self.id}, email='{self.email}', username='{self.username}')>\"",
      "metadata": {
        "file_path": "app/models/user.py",
        "chunk_type": "method",
        "name": "User.__repr__",
        "purpose": "Method __repr__",
        "dependencies": [],
        "access_level": "public",
        "class_name": "User",
        "method_name": "__repr__",
        "parameters": [
          "self"
        ],
        "return_type": "",
        "access": "private",
        "decorators": [],
        "is_async": false,
        "is_static": false,
        "is_classmethod": false
      }
    },
    {
      "type": "method",
      "name": "User.full_name",
      "content": "    def full_name(self) -> str:\n        \"\"\"Get user's full name\"\"\"\n        if self.first_name and self.last_name:\n            return f\"{self.first_name} {self.last_name}\"\n        return self.username",
      "metadata": {
        "file_path": "app/models/user.py",
        "chunk_type": "method",
        "name": "User.full_name",
        "purpose": "Get user's full name",
        "dependencies": [],
        "access_level": "public",
        "class_name": "User",
        "method_name": "full_name",
        "parameters": [
          "self"
        ],
        "return_type": "str",
        "access": "public",
        "decorators": [
          "property"
        ],
        "is_async": false,
        "is_static": false,
        "is_classmethod": false
      }
    },
    {
      "type": "method",
      "name": "User.to_dict",
      "content": "    def to_dict(self) -> dict:\n        \"\"\"Convert user to dictionary\"\"\"\n        return {\n            \"id\": self.id,\n            \"email\": self.email,\n            \"username\": self.username,\n            \"first_name\": self.first_name,\n            \"last_name\": self.last_name,\n            \"is_active\": self.is_active,\n            \"is_admin\": self.is_admin,\n            \"phone\": self.phone,\n            \"address\": self.address,\n            \"created_at\": self.created_at.isoformat() if self.created_at else None,\n            \"updated_at\": self.updated_at.isoformat() if self.updated_at else None\n        }",
      "metadata": {
        "file_path": "app/models/user.py",
        "chunk_type": "method",
        "name": "User.to_dict",
        "purpose": "Convert user to dictionary",
        "dependencies": [],
        "access_level": "public",
        "class_name": "User",
        "method_name": "to_dict",
        "parameters": [
          "self"
        ],
        "return_type": "dict",
        "access": "public",
        "decorators": [],
        "is_async": false,
        "is_static": false,
        "is_classmethod": false
      }
    },
    {
      "type": "contains",
      "source": "app/models/order.py:Order",
      "target": "app/models/order.py:Order.__repr__",
      "metadata": {
        "purpose": "class_method"
      }
    },
    {
      "type": "contains",
      "source": "app/models/order.py:Order",
      "target": "app/models/order.py:Order.item_count",
      "metadata": {
        "purpose": "class_method"
      }
    },
    {
      "type": "contains",
      "source": "app/models/order.py:Order",
      "target": "app/models/order.py:Order.to_dict",
      "metadata": {
        "purpose": "class_method"
      }
    },
    {
      "type": "method",
      "name": "Order.__repr__",
      "content": "    def __repr__(self):\n        return f\"<Order(id={self.id}, order_number='{self.order_number}', status='{self.status.value}')>\"",
      "metadata": {
        "file_path": "app/models/order.py",
        "chunk_type": "method",
        "name": "Order.__repr__",
        "purpose": "Method __repr__",
        "dependencies": [],
        "access_level": "public",
        "class_name": "Order",
        "method_name": "__repr__",
        "parameters": [
          "self"
        ],
        "return_type": "",
        "access": "private",
        "decorators": [],
        "is_async": false,
        "is_static": false,
        "is_classmethod": false
      }
    },
    {
      "type": "method",
      "name": "Order.item_count",
      "content": "    def item_count(self) -> int:\n        \"\"\"Get total number of items in order\"\"\"\n        return sum(item.quantity for item in self.items)",
      "metadata": {
        "file_path": "app/models/order.py",
        "chunk_type": "method",
        "name": "Order.item_count",
        "purpose": "Get total number of items in order",
        "dependencies": [],
        "access_level": "public",
        "class_name": "Order",
        "method_name": "item_count",
        "parameters": [
          "self"
        ],
        "return_type": "int",
        "access": "public",
        "decorators": [
          "property"
        ],
        "is_async": false,
        "is_static": false,
        "is_classmethod": false
      }
    },
    {
      "type": "method",
      "name": "Order.to_dict",
      "content": "    def to_dict(self) -> dict:\n        \"\"\"Convert order to dictionary\"\"\"\n        return {\n            \"id\": self.id,\n            \"user_id\": self.user_id,\n            \"order_number\": self.order_number,\n            \"status\": self.status.value,\n            \"subtotal\": float(self.subtotal) if self.subtotal else None,\n            \"tax_amount\": float(self.tax_amount) if self.tax_amount else None,\n            \"shipping_amount\": float(self.shipping_amount) if self.shipping_amount else None,\n            \"total_amount\": float(self.total_amount) if self.total_amount else None,\n            \"shipping_address\": self.shipping_address,\n            \"billing_address\": self.billing_address,\n            \"notes\": self.notes,\n            \"item_count\": self.item_count,\n            \"created_at\": self.created_at.isoformat() if self.created_at else None,\n            \"updated_at\": self.updated_at.isoformat() if self.updated_at else None\n        }",
      "metadata": {
        "file_path": "app/models/order.py",
        "chunk_type": "method",
        "name": "Order.to_dict",
        "purpose": "Convert order to dictionary",
        "dependencies": [],
        "access_level": "public",
        "class_name": "Order",
        "method_name": "to_dict",
        "parameters": [
          "self"
        ],
        "return_type": "dict",
        "access": "public",
        "decorators": [],
        "is_async": false,
        "is_static": false,
        "is_classmethod": false
      }
    },
    {
      "type": "contains",
      "source": "app/models/order.py:OrderItem",
      "target": "app/models/order.py:OrderItem.__repr__",
      "metadata": {
        "purpose": "class_method"
      }
    },
    {
      "type": "contains",
      "source": "app/models/order.py:OrderItem",
      "target": "app/models/order.py:OrderItem.to_dict",
      "metadata": {
        "purpose": "class_method"
      }
    },
    {
      "type": "method",
      "name": "OrderItem.__repr__",
      "content": "    def __repr__(self):\n        return f\"<OrderItem(id={self.id}, order_id={self.order_id}, product_id={self.product_id}, quantity={self.quantity})>\"",
      "metadata": {
        "file_path": "app/models/order.py",
        "chunk_type": "method",
        "name": "OrderItem.__repr__",
        "purpose": "Method __repr__",
        "dependencies": [],
        "access_level": "public",
        "class_name": "OrderItem",
        "method_name": "__repr__",
        "parameters": [
          "self"
        ],
        "return_type": "",
        "access": "private",
        "decorators": [],
        "is_async": false,
        "is_static": false,
        "is_classmethod": false
      }
    },
    {
      "type": "method",
      "name": "OrderItem.to_dict",
      "content": "    def to_dict(self) -> dict:\n        \"\"\"Convert order item to dictionary\"\"\"\n        return {\n            \"id\": self.id,\n            \"order_id\": self.order_id,\n            \"product_id\": self.product_id,\n            \"quantity\": self.quantity,\n            \"unit_price\": float(self.unit_price) if self.unit_price else None,\n            \"total_price\": float(self.total_price) if self.total_price else None,\n            \"created_at\": self.created_at.isoformat() if self.created_at else None\n        }",
      "metadata": {
        "file_path": "app/models/order.py",
        "chunk_type": "method",
        "name": "OrderItem.to_dict",
        "purpose": "Convert order item to dictionary",
        "dependencies": [],
        "access_level": "public",
        "class_name": "OrderItem",
        "method_name": "to_dict",
        "parameters": [
          "self"
        ],
        "return_type": "dict",
        "access": "public",
        "decorators": [],
        "is_async": false,
        "is_static": false,
        "is_classmethod": false
      }
    },
    {
      "type": "contains",
      "source": "app/models/product.py:Product",
      "target": "app/models/product.py:Product.__repr__",
      "metadata": {
        "purpose": "class_method"
      }
    },
    {
      "type": "contains",
      "source": "app/models/product.py:Product",
      "target": "app/models/product.py:Product.is_in_stock",
      "metadata": {
        "purpose": "class_method"
      }
    },
    {
      "type": "contains",
      "source": "app/models/product.py:Product",
      "target": "app/models/product.py:Product.to_dict",
      "metadata": {
        "purpose": "class_method"
      }
    },
    {
      "type": "method",
      "name": "Product.__repr__",
      "content": "    def __repr__(self):\n        return f\"<Product(id={self.id}, name='{self.name}', sku='{self.sku}')>\"",
      "metadata": {
        "file_path": "app/models/product.py",
        "chunk_type": "method",
        "name": "Product.__repr__",
        "purpose": "Method __repr__",
        "dependencies": [],
        "access_level": "public",
        "class_name": "Product",
        "method_name": "__repr__",
        "parameters": [
          "self"
        ],
        "return_type": "",
        "access": "private",
        "decorators": [],
        "is_async": false,
        "is_static": false,
        "is_classmethod": false
      }
    },
    {
      "type": "method",
      "name": "Product.is_in_stock",
      "content": "    def is_in_stock(self) -> bool:\n        \"\"\"Check if product is in stock\"\"\"\n        return self.stock_quantity > 0",
      "metadata": {
        "file_path": "app/models/product.py",
        "chunk_type": "method",
        "name": "Product.is_in_stock",
        "purpose": "Check if product is in stock",
        "dependencies": [],
        "access_level": "public",
        "class_name": "Product",
        "method_name": "is_in_stock",
        "parameters": [
          "self"
        ],
        "return_type": "bool",
        "access": "public",
        "decorators": [
          "property"
        ],
        "is_async": false,
        "is_static": false,
        "is_classmethod": false
      }
    },
    {
      "type": "method",
      "name": "Product.to_dict",
      "content": "    def to_dict(self) -> dict:\n        \"\"\"Convert product to dictionary\"\"\"\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"description\": self.description,\n            \"price\": float(self.price) if self.price else None,\n            \"sku\": self.sku,\n            \"stock_quantity\": self.stock_quantity,\n            \"is_active\": self.is_active,\n            \"is_in_stock\": self.is_in_stock,\n            \"weight\": float(self.weight) if self.weight else None,\n            \"dimensions\": self.dimensions,\n            \"category_id\": self.category_id,\n            \"created_at\": self.created_at.isoformat() if self.created_at else None,\n            \"updated_at\": self.updated_at.isoformat() if self.updated_at else None\n        }",
      "metadata": {
        "file_path": "app/models/product.py",
        "chunk_type": "method",
        "name": "Product.to_dict",
        "purpose": "Convert product to dictionary",
        "dependencies": [],
        "access_level": "public",
        "class_name": "Product",
        "method_name": "to_dict",
        "parameters": [
          "self"
        ],
        "return_type": "dict",
        "access": "public",
        "decorators": [],
        "is_async": false,
        "is_static": false,
        "is_classmethod": false
      }
    },
    {
      "type": "contains",
      "source": "app/models/product.py:ProductImage",
      "target": "app/models/product.py:ProductImage.__repr__",
      "metadata": {
        "purpose": "class_method"
      }
    },
    {
      "type": "contains",
      "source": "app/models/product.py:ProductImage",
      "target": "app/models/product.py:ProductImage.to_dict",
      "metadata": {
        "purpose": "class_method"
      }
    },
    {
      "type": "method",
      "name": "ProductImage.__repr__",
      "content": "    def __repr__(self):\n        return f\"<ProductImage(id={self.id}, product_id={self.product_id}, url='{self.image_url}')>\"",
      "metadata": {
        "file_path": "app/models/product.py",
        "chunk_type": "method",
        "name": "ProductImage.__repr__",
        "purpose": "Method __repr__",
        "dependencies": [],
        "access_level": "public",
        "class_name": "ProductImage",
        "method_name": "__repr__",
        "parameters": [
          "self"
        ],
        "return_type": "",
        "access": "private",
        "decorators": [],
        "is_async": false,
        "is_static": false,
        "is_classmethod": false
      }
    },
    {
      "type": "method",
      "name": "ProductImage.to_dict",
      "content": "    def to_dict(self) -> dict:\n        \"\"\"Convert product image to dictionary\"\"\"\n        return {\n            \"id\": self.id,\n            \"product_id\": self.product_id,\n            \"image_url\": self.image_url,\n            \"alt_text\": self.alt_text,\n            \"is_primary\": self.is_primary,\n            \"sort_order\": self.sort_order,\n            \"created_at\": self.created_at.isoformat() if self.created_at else None\n        }",
      "metadata": {
        "file_path": "app/models/product.py",
        "chunk_type": "method",
        "name": "ProductImage.to_dict",
        "purpose": "Convert product image to dictionary",
        "dependencies": [],
        "access_level": "public",
        "class_name": "ProductImage",
        "method_name": "to_dict",
        "parameters": [
          "self"
        ],
        "return_type": "dict",
        "access": "public",
        "decorators": [],
        "is_async": false,
        "is_static": false,
        "is_classmethod": false
      }
    },
    {
      "type": "contains",
      "source": "app/models/category.py:Category",
      "target": "app/models/category.py:Category.__repr__",
      "metadata": {
        "purpose": "class_method"
      }
    },
    {
      "type": "contains",
      "source": "app/models/category.py:Category",
      "target": "app/models/category.py:Category.product_count",
      "metadata": {
        "purpose": "class_method"
      }
    },
    {
      "type": "contains",
      "source": "app/models/category.py:Category",
      "target": "app/models/category.py:Category.to_dict",
      "metadata": {
        "purpose": "class_method"
      }
    },
    {
      "type": "method",
      "name": "Category.__repr__",
      "content": "    def __repr__(self):\n        return f\"<Category(id={self.id}, name='{self.name}', slug='{self.slug}')>\"",
      "metadata": {
        "file_path": "app/models/category.py",
        "chunk_type": "method",
        "name": "Category.__repr__",
        "purpose": "Method __repr__",
        "dependencies": [],
        "access_level": "public",
        "class_name": "Category",
        "method_name": "__repr__",
        "parameters": [
          "self"
        ],
        "return_type": "",
        "access": "private",
        "decorators": [],
        "is_async": false,
        "is_static": false,
        "is_classmethod": false
      }
    },
    {
      "type": "method",
      "name": "Category.product_count",
      "content": "    def product_count(self) -> int:\n        \"\"\"Get number of products in this category\"\"\"\n        return len(self.products)",
      "metadata": {
        "file_path": "app/models/category.py",
        "chunk_type": "method",
        "name": "Category.product_count",
        "purpose": "Get number of products in this category",
        "dependencies": [],
        "access_level": "public",
        "class_name": "Category",
        "method_name": "product_count",
        "parameters": [
          "self"
        ],
        "return_type": "int",
        "access": "public",
        "decorators": [
          "property"
        ],
        "is_async": false,
        "is_static": false,
        "is_classmethod": false
      }
    },
    {
      "type": "method",
      "name": "Category.to_dict",
      "content": "    def to_dict(self) -> dict:\n        \"\"\"Convert category to dictionary\"\"\"\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"slug\": self.slug,\n            \"description\": self.description,\n            \"parent_id\": self.parent_id,\n            \"is_active\": self.is_active,\n            \"sort_order\": self.sort_order,\n            \"product_count\": self.product_count,\n            \"created_at\": self.created_at.isoformat() if self.created_at else None,\n            \"updated_at\": self.updated_at.isoformat() if self.updated_at else None\n        }",
      "metadata": {
        "file_path": "app/models/category.py",
        "chunk_type": "method",
        "name": "Category.to_dict",
        "purpose": "Convert category to dictionary",
        "dependencies": [],
        "access_level": "public",
        "class_name": "Category",
        "method_name": "to_dict",
        "parameters": [
          "self"
        ],
        "return_type": "dict",
        "access": "public",
        "decorators": [],
        "is_async": false,
        "is_static": false,
        "is_classmethod": false
      }
    },
    {
      "type": "contains",
      "source": "app/schemas/user.py:UserCreate",
      "target": "app/schemas/user.py:UserCreate.validate_password",
      "metadata": {
        "purpose": "class_method"
      }
    },
    {
      "type": "contains",
      "source": "app/schemas/user.py:UserCreate",
      "target": "app/schemas/user.py:UserCreate.validate_username",
      "metadata": {
        "purpose": "class_method"
      }
    },
    {
      "type": "method",
      "name": "UserCreate.validate_password",
      "content": "    def validate_password(cls, v):\n        if len(v) < 8:\n            raise ValueError('Password must be at least 8 characters long')\n        return v",
      "metadata": {
        "file_path": "app/schemas/user.py",
        "chunk_type": "method",
        "name": "UserCreate.validate_password",
        "purpose": "Method validate_password",
        "dependencies": [],
        "access_level": "public",
        "class_name": "UserCreate",
        "method_name": "validate_password",
        "parameters": [
          "cls",
          "v"
        ],
        "return_type": "",
        "access": "public",
        "decorators": [
          "validator('password')"
        ],
        "is_async": false,
        "is_static": false,
        "is_classmethod": false
      }
    },
    {
      "type": "method",
      "name": "UserCreate.validate_username",
      "content": "    def validate_username(cls, v):\n        if len(v) < 3:\n            raise ValueError('Username must be at least 3 characters long')\n        return v",
      "metadata": {
        "file_path": "app/schemas/user.py",
        "chunk_type": "method",
        "name": "UserCreate.validate_username",
        "purpose": "Method validate_username",
        "dependencies": [],
        "access_level": "public",
        "class_name": "UserCreate",
        "method_name": "validate_username",
        "parameters": [
          "cls",
          "v"
        ],
        "return_type": "",
        "access": "public",
        "decorators": [
          "validator('username')"
        ],
        "is_async": false,
        "is_static": false,
        "is_classmethod": false
      }
    },
    {
      "type": "contains",
      "source": "app/schemas/order.py:OrderItemCreate",
      "target": "app/schemas/order.py:OrderItemCreate.validate_quantity",
      "metadata": {
        "purpose": "class_method"
      }
    },
    {
      "type": "method",
      "name": "OrderItemCreate.validate_quantity",
      "content": "    def validate_quantity(cls, v):\n        if v <= 0:\n            raise ValueError('Quantity must be greater than 0')\n        return v",
      "metadata": {
        "file_path": "app/schemas/order.py",
        "chunk_type": "method",
        "name": "OrderItemCreate.validate_quantity",
        "purpose": "Method validate_quantity",
        "dependencies": [],
        "access_level": "public",
        "class_name": "OrderItemCreate",
        "method_name": "validate_quantity",
        "parameters": [
          "cls",
          "v"
        ],
        "return_type": "",
        "access": "public",
        "decorators": [
          "validator('quantity')"
        ],
        "is_async": false,
        "is_static": false,
        "is_classmethod": false
      }
    },
    {
      "type": "contains",
      "source": "app/schemas/order.py:OrderCreate",
      "target": "app/schemas/order.py:OrderCreate.validate_items",
      "metadata": {
        "purpose": "class_method"
      }
    },
    {
      "type": "method",
      "name": "OrderCreate.validate_items",
      "content": "    def validate_items(cls, v):\n        if not v:\n            raise ValueError('Order must have at least one item')\n        return v",
      "metadata": {
        "file_path": "app/schemas/order.py",
        "chunk_type": "method",
        "name": "OrderCreate.validate_items",
        "purpose": "Method validate_items",
        "dependencies": [],
        "access_level": "public",
        "class_name": "OrderCreate",
        "method_name": "validate_items",
        "parameters": [
          "cls",
          "v"
        ],
        "return_type": "",
        "access": "public",
        "decorators": [
          "validator('items')"
        ],
        "is_async": false,
        "is_static": false,
        "is_classmethod": false
      }
    },
    {
      "type": "contains",
      "source": "app/schemas/product.py:ProductCreate",
      "target": "app/schemas/product.py:ProductCreate.validate_price",
      "metadata": {
        "purpose": "class_method"
      }
    },
    {
      "type": "contains",
      "source": "app/schemas/product.py:ProductCreate",
      "target": "app/schemas/product.py:ProductCreate.validate_stock",
      "metadata": {
        "purpose": "class_method"
      }
    },
    {
      "type": "method",
      "name": "ProductCreate.validate_price",
      "content": "    def validate_price(cls, v):\n        if v <= 0:\n            raise ValueError('Price must be greater than 0')\n        return v",
      "metadata": {
        "file_path": "app/schemas/product.py",
        "chunk_type": "method",
        "name": "ProductCreate.validate_price",
        "purpose": "Method validate_price",
        "dependencies": [],
        "access_level": "public",
        "class_name": "ProductCreate",
        "method_name": "validate_price",
        "parameters": [
          "cls",
          "v"
        ],
        "return_type": "",
        "access": "public",
        "decorators": [
          "validator('price')"
        ],
        "is_async": false,
        "is_static": false,
        "is_classmethod": false
      }
    },
    {
      "type": "method",
      "name": "ProductCreate.validate_stock",
      "content": "    def validate_stock(cls, v):\n        if v < 0:\n            raise ValueError('Stock quantity cannot be negative')\n        return v",
      "metadata": {
        "file_path": "app/schemas/product.py",
        "chunk_type": "method",
        "name": "ProductCreate.validate_stock",
        "purpose": "Method validate_stock",
        "dependencies": [],
        "access_level": "public",
        "class_name": "ProductCreate",
        "method_name": "validate_stock",
        "parameters": [
          "cls",
          "v"
        ],
        "return_type": "",
        "access": "public",
        "decorators": [
          "validator('stock_quantity')"
        ],
        "is_async": false,
        "is_static": false,
        "is_classmethod": false
      }
    },
    {
      "type": "contains",
      "source": "app/schemas/category.py:CategoryCreate",
      "target": "app/schemas/category.py:CategoryCreate.validate_name",
      "metadata": {
        "purpose": "class_method"
      }
    },
    {
      "type": "contains",
      "source": "app/schemas/category.py:CategoryCreate",
      "target": "app/schemas/category.py:CategoryCreate.validate_slug",
      "metadata": {
        "purpose": "class_method"
      }
    },
    {
      "type": "method",
      "name": "CategoryCreate.validate_name",
      "content": "    def validate_name(cls, v):\n        if len(v) < 2:\n            raise ValueError('Category name must be at least 2 characters long')\n        return v",
      "metadata": {
        "file_path": "app/schemas/category.py",
        "chunk_type": "method",
        "name": "CategoryCreate.validate_name",
        "purpose": "Method validate_name",
        "dependencies": [],
        "access_level": "public",
        "class_name": "CategoryCreate",
        "method_name": "validate_name",
        "parameters": [
          "cls",
          "v"
        ],
        "return_type": "",
        "access": "public",
        "decorators": [
          "validator('name')"
        ],
        "is_async": false,
        "is_static": false,
        "is_classmethod": false
      }
    },
    {
      "type": "method",
      "name": "CategoryCreate.validate_slug",
      "content": "    def validate_slug(cls, v):\n        if not v.replace('-', '').replace('_', '').isalnum():\n            raise ValueError('Slug must contain only alphanumeric characters, hyphens, and underscores')\n        return v",
      "metadata": {
        "file_path": "app/schemas/category.py",
        "chunk_type": "method",
        "name": "CategoryCreate.validate_slug",
        "purpose": "Method validate_slug",
        "dependencies": [],
        "access_level": "public",
        "class_name": "CategoryCreate",
        "method_name": "validate_slug",
        "parameters": [
          "cls",
          "v"
        ],
        "return_type": "",
        "access": "public",
        "decorators": [
          "validator('slug')"
        ],
        "is_async": false,
        "is_static": false,
        "is_classmethod": false
      }
    },
    {
      "type": "contains",
      "source": "app/services/notification.py:NotificationService",
      "target": "app/services/notification.py:NotificationService.__init__",
      "metadata": {
        "purpose": "class_method"
      }
    },
    {
      "type": "contains",
      "source": "app/services/notification.py:NotificationService",
      "target": "app/services/notification.py:NotificationService.publish_notification",
      "metadata": {
        "purpose": "class_method"
      }
    },
    {
      "type": "contains",
      "source": "app/services/notification.py:NotificationService",
      "target": "app/services/notification.py:NotificationService.notify_order_update",
      "metadata": {
        "purpose": "class_method"
      }
    },
    {
      "type": "contains",
      "source": "app/services/notification.py:NotificationService",
      "target": "app/services/notification.py:NotificationService.notify_stock_update",
      "metadata": {
        "purpose": "class_method"
      }
    },
    {
      "type": "contains",
      "source": "app/services/notification.py:NotificationService",
      "target": "app/services/notification.py:NotificationService.notify_system_alert",
      "metadata": {
        "purpose": "class_method"
      }
    },
    {
      "type": "method",
      "name": "NotificationService.__init__",
      "content": "    def __init__(self):\n        self.redis_client = redis.from_url(settings.REDIS_URL)",
      "metadata": {
        "file_path": "app/services/notification.py",
        "chunk_type": "method",
        "name": "NotificationService.__init__",
        "purpose": "Method __init__",
        "dependencies": [],
        "access_level": "public",
        "class_name": "NotificationService",
        "method_name": "__init__",
        "parameters": [
          "self"
        ],
        "return_type": "",
        "access": "private",
        "decorators": [],
        "is_async": false,
        "is_static": false,
        "is_classmethod": false
      }
    },
    {
      "type": "method",
      "name": "NotificationService.publish_notification",
      "content": "    def publish_notification(\n        self,\n        channel: str,\n        message: Dict[str, Any]\n    ) -> bool:\n        \"\"\"Publish notification to Redis channel\"\"\"\n        try:\n            self.redis_client.publish(channel, json.dumps(message))\n            return True\n        except Exception as e:\n            print(f\"Failed to publish notification: {e}\")\n            return False",
      "metadata": {
        "file_path": "app/services/notification.py",
        "chunk_type": "method",
        "name": "NotificationService.publish_notification",
        "purpose": "Publish notification to Redis channel",
        "dependencies": [],
        "access_level": "public",
        "class_name": "NotificationService",
        "method_name": "publish_notification",
        "parameters": [
          "self",
          "channel: str",
          "message: Dict[str, Any]"
        ],
        "return_type": "bool",
        "access": "public",
        "decorators": [],
        "is_async": false,
        "is_static": false,
        "is_classmethod": false
      }
    },
    {
      "type": "method",
      "name": "NotificationService.notify_order_update",
      "content": "    def notify_order_update(self, user_id: int, order_id: int, status: str) -> bool:\n        \"\"\"Notify user about order status update\"\"\"\n        message = {\n            \"type\": \"order_update\",\n            \"user_id\": user_id,\n            \"order_id\": order_id,\n            \"status\": status,\n            \"timestamp\": str(datetime.utcnow())\n        }\n        return self.publish_notification(f\"user:{user_id}:notifications\", message)",
      "metadata": {
        "file_path": "app/services/notification.py",
        "chunk_type": "method",
        "name": "NotificationService.notify_order_update",
        "purpose": "Notify user about order status update",
        "dependencies": [],
        "access_level": "public",
        "class_name": "NotificationService",
        "method_name": "notify_order_update",
        "parameters": [
          "self",
          "user_id: int",
          "order_id: int",
          "status: str"
        ],
        "return_type": "bool",
        "access": "public",
        "decorators": [],
        "is_async": false,
        "is_static": false,
        "is_classmethod": false
      }
    },
    {
      "type": "method",
      "name": "NotificationService.notify_stock_update",
      "content": "    def notify_stock_update(self, product_id: int, new_stock: int) -> bool:\n        \"\"\"Notify about product stock update\"\"\"\n        message = {\n            \"type\": \"stock_update\",\n            \"product_id\": product_id,\n            \"new_stock\": new_stock,\n            \"timestamp\": str(datetime.utcnow())\n        }\n        return self.publish_notification(\"product:stock_updates\", message)",
      "metadata": {
        "file_path": "app/services/notification.py",
        "chunk_type": "method",
        "name": "NotificationService.notify_stock_update",
        "purpose": "Notify about product stock update",
        "dependencies": [],
        "access_level": "public",
        "class_name": "NotificationService",
        "method_name": "notify_stock_update",
        "parameters": [
          "self",
          "product_id: int",
          "new_stock: int"
        ],
        "return_type": "bool",
        "access": "public",
        "decorators": [],
        "is_async": false,
        "is_static": false,
        "is_classmethod": false
      }
    },
    {
      "type": "method",
      "name": "NotificationService.notify_system_alert",
      "content": "    def notify_system_alert(self, alert_type: str, message: str) -> bool:\n        \"\"\"Notify system administrators about alerts\"\"\"\n        alert_message = {\n            \"type\": \"system_alert\",\n            \"alert_type\": alert_type,\n            \"message\": message,\n            \"timestamp\": str(datetime.utcnow())\n        }\n        return self.publish_notification(\"system:alerts\", alert_message)",
      "metadata": {
        "file_path": "app/services/notification.py",
        "chunk_type": "method",
        "name": "NotificationService.notify_system_alert",
        "purpose": "Notify system administrators about alerts",
        "dependencies": [],
        "access_level": "public",
        "class_name": "NotificationService",
        "method_name": "notify_system_alert",
        "parameters": [
          "self",
          "alert_type: str",
          "message: str"
        ],
        "return_type": "bool",
        "access": "public",
        "decorators": [],
        "is_async": false,
        "is_static": false,
        "is_classmethod": false
      }
    },
    {
      "type": "contains",
      "source": "app/services/email.py:EmailService",
      "target": "app/services/email.py:EmailService.__init__",
      "metadata": {
        "purpose": "class_method"
      }
    },
    {
      "type": "contains",
      "source": "app/services/email.py:EmailService",
      "target": "app/services/email.py:EmailService.send_email",
      "metadata": {
        "purpose": "class_method"
      }
    },
    {
      "type": "contains",
      "source": "app/services/email.py:EmailService",
      "target": "app/services/email.py:EmailService.send_bulk_email",
      "metadata": {
        "purpose": "class_method"
      }
    },
    {
      "type": "contains",
      "source": "app/services/email.py:EmailService",
      "target": "app/services/email.py:EmailService.send_order_confirmation",
      "metadata": {
        "purpose": "class_method"
      }
    },
    {
      "type": "contains",
      "source": "app/services/email.py:EmailService",
      "target": "app/services/email.py:EmailService.send_password_reset",
      "metadata": {
        "purpose": "class_method"
      }
    },
    {
      "type": "method",
      "name": "EmailService.__init__",
      "content": "    def __init__(self):\n        self.smtp_host = settings.SMTP_HOST\n        self.smtp_port = settings.SMTP_PORT\n        self.smtp_user = settings.SMTP_USER\n        self.smtp_password = settings.SMTP_PASSWORD",
      "metadata": {
        "file_path": "app/services/email.py",
        "chunk_type": "method",
        "name": "EmailService.__init__",
        "purpose": "Method __init__",
        "dependencies": [],
        "access_level": "public",
        "class_name": "EmailService",
        "method_name": "__init__",
        "parameters": [
          "self"
        ],
        "return_type": "",
        "access": "private",
        "decorators": [],
        "is_async": false,
        "is_static": false,
        "is_classmethod": false
      }
    },
    {
      "type": "method",
      "name": "EmailService.send_email",
      "content": "    def send_email(\n        self,\n        to_email: str,\n        subject: str,\n        body: str,\n        html_body: Optional[str] = None\n    ) -> bool:\n        \"\"\"Send email to single recipient\"\"\"\n        if not all([self.smtp_host, self.smtp_user, self.smtp_password]):\n            print(\"SMTP configuration not available\")\n            return False\n        \n        try:\n            msg = MIMEMultipart('alternative')\n            msg['From'] = self.smtp_user\n            msg['To'] = to_email\n            msg['Subject'] = subject\n            \n            # Add text part\n            text_part = MIMEText(body, 'plain')\n            msg.attach(text_part)\n            \n            # Add HTML part if provided\n            if html_body:\n                html_part = MIMEText(html_body, 'html')\n                msg.attach(html_part)\n            \n            # Send email\n            with smtplib.SMTP(self.smtp_host, self.smtp_port) as server:\n                server.starttls()\n                server.login(self.smtp_user, self.smtp_password)\n                server.send_message(msg)\n            \n            return True\n            \n        except Exception as e:\n            print(f\"Failed to send email: {e}\")\n            return False",
      "metadata": {
        "file_path": "app/services/email.py",
        "chunk_type": "method",
        "name": "EmailService.send_email",
        "purpose": "Send email to single recipient",
        "dependencies": [],
        "access_level": "public",
        "class_name": "EmailService",
        "method_name": "send_email",
        "parameters": [
          "self",
          "to_email: str",
          "subject: str",
          "body: str",
          "html_body: Optional[str]"
        ],
        "return_type": "bool",
        "access": "public",
        "decorators": [],
        "is_async": false,
        "is_static": false,
        "is_classmethod": false
      }
    },
    {
      "type": "method",
      "name": "EmailService.send_bulk_email",
      "content": "    def send_bulk_email(\n        self,\n        to_emails: List[str],\n        subject: str,\n        body: str,\n        html_body: Optional[str] = None\n    ) -> int:\n        \"\"\"Send email to multiple recipients\"\"\"\n        success_count = 0\n        for email in to_emails:\n            if self.send_email(email, subject, body, html_body):\n                success_count += 1\n        return success_count",
      "metadata": {
        "file_path": "app/services/email.py",
        "chunk_type": "method",
        "name": "EmailService.send_bulk_email",
        "purpose": "Send email to multiple recipients",
        "dependencies": [],
        "access_level": "public",
        "class_name": "EmailService",
        "method_name": "send_bulk_email",
        "parameters": [
          "self",
          "to_emails: List[str]",
          "subject: str",
          "body: str",
          "html_body: Optional[str]"
        ],
        "return_type": "int",
        "access": "public",
        "decorators": [],
        "is_async": false,
        "is_static": false,
        "is_classmethod": false
      }
    },
    {
      "type": "method",
      "name": "EmailService.send_order_confirmation",
      "content": "    def send_order_confirmation(self, user_email: str, order_number: str) -> bool:\n        \"\"\"Send order confirmation email\"\"\"\n        subject = f\"Order Confirmation - {order_number}\"\n        body = f\"\"\"\n        Thank you for your order!\n        \n        Order Number: {order_number}\n        \n        We have received your order and will process it shortly.\n        \n        Best regards,\n        E-commerce Team\n        \"\"\"\n        \n        html_body = f\"\"\"\n        <html>\n        <body>\n            <h2>Order Confirmation</h2>\n            <p>Thank you for your order!</p>\n            <p><strong>Order Number:</strong> {order_number}</p>\n            <p>We have received your order and will process it shortly.</p>\n            <p>Best regards,<br>E-commerce Team</p>\n        </body>\n        </html>\n        \"\"\"\n        \n        return self.send_email(user_email, subject, body, html_body)",
      "metadata": {
        "file_path": "app/services/email.py",
        "chunk_type": "method",
        "name": "EmailService.send_order_confirmation",
        "purpose": "Send order confirmation email",
        "dependencies": [],
        "access_level": "public",
        "class_name": "EmailService",
        "method_name": "send_order_confirmation",
        "parameters": [
          "self",
          "user_email: str",
          "order_number: str"
        ],
        "return_type": "bool",
        "access": "public",
        "decorators": [],
        "is_async": false,
        "is_static": false,
        "is_classmethod": false
      }
    },
    {
      "type": "method",
      "name": "EmailService.send_password_reset",
      "content": "    def send_password_reset(self, user_email: str, reset_token: str) -> bool:\n        \"\"\"Send password reset email\"\"\"\n        subject = \"Password Reset Request\"\n        reset_url = f\"https://yourapp.com/reset-password?token={reset_token}\"\n        \n        body = f\"\"\"\n        Password Reset Request\n        \n        You requested a password reset for your account.\n        \n        Click the link below to reset your password:\n        {reset_url}\n        \n        This link will expire in 1 hour.\n        \n        If you didn't request this, please ignore this email.\n        \n        Best regards,\n        E-commerce Team\n        \"\"\"\n        \n        html_body = f\"\"\"\n        <html>\n        <body>\n            <h2>Password Reset Request</h2>\n            <p>You requested a password reset for your account.</p>\n            <p><a href=\"{reset_url}\">Click here to reset your password</a></p>\n            <p>This link will expire in 1 hour.</p>\n            <p>If you didn't request this, please ignore this email.</p>\n            <p>Best regards,<br>E-commerce Team</p>\n        </body>\n        </html>\n        \"\"\"\n        \n        return self.send_email(user_email, subject, body, html_body)",
      "metadata": {
        "file_path": "app/services/email.py",
        "chunk_type": "method",
        "name": "EmailService.send_password_reset",
        "purpose": "Send password reset email",
        "dependencies": [],
        "access_level": "public",
        "class_name": "EmailService",
        "method_name": "send_password_reset",
        "parameters": [
          "self",
          "user_email: str",
          "reset_token: str"
        ],
        "return_type": "bool",
        "access": "public",
        "decorators": [],
        "is_async": false,
        "is_static": false,
        "is_classmethod": false
      }
    }
  ],
  "total_chunks": 173,
  "total_relationships": 70
}